
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000510  00800100  00000fea  0000107e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fea  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001a  00800610  00800610  0000158e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000158e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000015c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  00001600  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000178e  00000000  00000000  000016c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a9f  00000000  00000000  00002e4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bf8  00000000  00000000  000038ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000194  00000000  00000000  000044e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005fc  00000000  00000000  0000467c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000034c  00000000  00000000  00004c78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00004fc4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 87 00 	jmp	0x10e	; 0x10e <__ctors_end>
   4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  10:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  14:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  18:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  1c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  20:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  24:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  28:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  2c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  30:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  34:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  38:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  3c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  40:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  44:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  48:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  4c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  50:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  54:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  58:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  5c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  60:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  64:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  68:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  6c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  70:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  74:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  78:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  7c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  80:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  84:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  88:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  8c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  90:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  94:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  98:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  9c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  ac:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b4:	08 00       	.word	0x0008	; ????
  b6:	00 00       	nop
  b8:	be 92       	st	-X, r11
  ba:	24 49       	sbci	r18, 0x94	; 148
  bc:	12 3e       	cpi	r17, 0xE2	; 226
  be:	ab aa       	std	Y+51, r10	; 0x33
  c0:	aa 2a       	or	r10, r26
  c2:	be cd       	rjmp	.-1156   	; 0xfffffc40 <__eeprom_end+0xff7efc40>
  c4:	cc cc       	rjmp	.-1640   	; 0xfffffa5e <__eeprom_end+0xff7efa5e>
  c6:	4c 3e       	cpi	r20, 0xEC	; 236
  c8:	00 00       	nop
  ca:	00 80       	ld	r0, Z
  cc:	be ab       	std	Y+54, r27	; 0x36
  ce:	aa aa       	std	Y+50, r10	; 0x32
  d0:	aa 3e       	cpi	r26, 0xEA	; 234
  d2:	00 00       	nop
  d4:	00 00       	nop
  d6:	bf 00       	.word	0x00bf	; ????
  d8:	00 00       	nop
  da:	80 3f       	cpi	r24, 0xF0	; 240
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	00 08       	sbc	r0, r0
  e2:	41 78       	andi	r20, 0x81	; 129
  e4:	d3 bb       	out	0x13, r29	; 19
  e6:	43 87       	std	Z+11, r20	; 0x0b
  e8:	d1 13       	cpse	r29, r17
  ea:	3d 19       	sub	r19, r13
  ec:	0e 3c       	cpi	r16, 0xCE	; 206
  ee:	c3 bd       	out	0x23, r28	; 35
  f0:	42 82       	std	Z+2, r4	; 0x02
  f2:	ad 2b       	or	r26, r29
  f4:	3e 68       	ori	r19, 0x8E	; 142
  f6:	ec 82       	std	Y+4, r14	; 0x04
  f8:	76 be       	out	0x36, r7	; 54
  fa:	d9 8f       	std	Y+25, r29	; 0x19
  fc:	e1 a9       	ldd	r30, Z+49	; 0x31
  fe:	3e 4c       	sbci	r19, 0xCE	; 206
 100:	80 ef       	ldi	r24, 0xF0	; 240
 102:	ff be       	out	0x3f, r15	; 63
 104:	01 c4       	rjmp	.+2050   	; 0x908 <Params+0x6>
 106:	ff 7f       	andi	r31, 0xFF	; 255
 108:	3f 00       	.word	0x003f	; ????
 10a:	00 00       	nop
	...

0000010e <__ctors_end>:
 10e:	11 24       	eor	r1, r1
 110:	1f be       	out	0x3f, r1	; 63
 112:	cf ef       	ldi	r28, 0xFF	; 255
 114:	d8 e0       	ldi	r29, 0x08	; 8
 116:	de bf       	out	0x3e, r29	; 62
 118:	cd bf       	out	0x3d, r28	; 61

0000011a <__do_copy_data>:
 11a:	16 e0       	ldi	r17, 0x06	; 6
 11c:	a0 e0       	ldi	r26, 0x00	; 0
 11e:	b1 e0       	ldi	r27, 0x01	; 1
 120:	ea ee       	ldi	r30, 0xEA	; 234
 122:	ff e0       	ldi	r31, 0x0F	; 15
 124:	02 c0       	rjmp	.+4      	; 0x12a <__do_copy_data+0x10>
 126:	05 90       	lpm	r0, Z+
 128:	0d 92       	st	X+, r0
 12a:	a0 31       	cpi	r26, 0x10	; 16
 12c:	b1 07       	cpc	r27, r17
 12e:	d9 f7       	brne	.-10     	; 0x126 <__do_copy_data+0xc>

00000130 <__do_clear_bss>:
 130:	26 e0       	ldi	r18, 0x06	; 6
 132:	a0 e1       	ldi	r26, 0x10	; 16
 134:	b6 e0       	ldi	r27, 0x06	; 6
 136:	01 c0       	rjmp	.+2      	; 0x13a <.do_clear_bss_start>

00000138 <.do_clear_bss_loop>:
 138:	1d 92       	st	X+, r1

0000013a <.do_clear_bss_start>:
 13a:	aa 32       	cpi	r26, 0x2A	; 42
 13c:	b2 07       	cpc	r27, r18
 13e:	e1 f7       	brne	.-8      	; 0x138 <.do_clear_bss_loop>
 140:	0e 94 d5 04 	call	0x9aa	; 0x9aa <main>
 144:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <_exit>

00000148 <__bad_interrupt>:
 148:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014c <Mega328P_Init>:
		   .set	      temp,0			//Adress temporary value to 0

		   .section   ".text"			//Defines a text section of the program.
		   .global    Mega328P_Init
Mega328P_Init:
		   ldi    r16,0x07				//PB0(R*W),PB1(RS),PB2(E) as fixed outputs
 14c:	07 e0       	ldi	r16, 0x07	; 7
		   out    DDRB,r16				//Set pins PB0-PB2 as outputs
 14e:	04 b9       	out	0x04, r16	; 4
		   ldi    r16,0					//Clear r16
 150:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//Clear the Port B data register
 152:	05 b9       	out	0x05, r16	; 5
		   out    U2X0,r16				//initialize UART, 8bits, no parity, 1 stop, 9600
 154:	01 b9       	out	0x01, r16	; 1
		   ldi    r17,0x0				//clear r17
 156:	10 e0       	ldi	r17, 0x00	; 0
		   ldi    r16,0x67				//set r16 to 0x67, 01100111
 158:	07 e6       	ldi	r16, 0x67	; 103
		   sts	  UBRR0H,r17			//Clear buad rate high register
 15a:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		   sts	  UBRR0L,r16			//Set baud rate low register to 0x67
 15e:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
										//Together baud rate is set to 0x67
		   ldi	  r16,24				//load 0x18,00011000, into r16
 162:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 164:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ldi	  r16,6					//set r16 to 0x06, 00000110
 168:	06 e0       	ldi	r16, 0x06	; 6
		   sts    UCSR0C,r16			//Set bit 1 and 2 of the USART Control and Status Register 0 C.
 16a:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
										//Exstablishes 8-bit character size for receiving/transmission
		   ldi    r16,0x87				//initialize ADC, 10000111
 16e:	07 e8       	ldi	r16, 0x87	; 135
		   sts	  ADCSRA,r16			//Sets bit 0,1,2, and 7 of the ADC Control and Status Register A.
 170:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
										//bits 2-0 set the division factor for the system clock and the input clock to 128
										//bit 7 enables ADC
		   ldi    r16,0x40				//set r16 to 0x40, 01000000
 174:	00 e4       	ldi	r16, 0x40	; 64
		   sts    ADMUX,r16				//Sets bit 6 of the ADC multiplier selection register.
 176:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
										//Sets the voltage reference of the ADC to Vcc with external capacitor with Aref pin
		   ldi    r16,0					//clear r16 
 17a:	00 e0       	ldi	r16, 0x00	; 0
		   sts    ADCSRB,r16			//clear ADC Control and Status Register B
 17c:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		   ldi    r16,0xFE				//set r16 to 0xFE, 11111110
 180:	0e ef       	ldi	r16, 0xFE	; 254
		   sts    DIDR0,r16				//set bits 1-7 of the Digital Input Disable Register 0.
 182:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
										//Effectively turns off digital input buffers from pins ADC7-ADC1. Prevents digital input
		   ldi    r16,0xFF				//set r16 to 0xFF, 11111111
 186:	0f ef       	ldi	r16, 0xFF	; 255
		   sts    DIDR1,r16				//set bits 0-1 of the Digital Input Disable Register 1.
 188:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
										//Effectively turns off digital input on pins AIN1 and AIN0. 
										//This is a two bit register so there are only two bits that can be set
		   ret							//Return to main
 18c:	08 95       	ret

0000018e <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
		   call	  UART_Off				//stop receiving/transmitting
 18e:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 192:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 194:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 196:	00 91 13 06 	lds	r16, 0x0613	; 0x800613 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 19a:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,4					//load 0x04 into r16 ***
 19c:	04 e0       	ldi	r16, 0x04	; 4
		   out    PORTB,r16				//load 0x04 to Port B data register ***
 19e:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop ***
 1a0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 1a4:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 1a6:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop. ***
 1a8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
		   call	  UART_On				//resume receiving/transmitting
 1ac:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
		   ret							//return from where called
 1b0:	08 95       	ret

000001b2 <LCD_Delay>:

.global LCD_Delay
LCD_Delay:
		   ldi    r16,0xFA				//set outer loop iterator
 1b2:	0a ef       	ldi	r16, 0xFA	; 250

000001b4 <D0>:
D0:	       ldi    r17,0xFF				//set inner loop iterator
 1b4:	1f ef       	ldi	r17, 0xFF	; 255

000001b6 <D1>:
D1:	       dec    r17					//decrement inner iterator
 1b6:	1a 95       	dec	r17
		   brne	  D1					//if D1 != 0 stay in loop
 1b8:	f1 f7       	brne	.-4      	; 0x1b6 <D1>
		   dec    r16					//decrement out loop
 1ba:	0a 95       	dec	r16
		   brne	  D0					//id D0 != 0 stay in loop
 1bc:	d9 f7       	brne	.-10     	; 0x1b4 <D0>
										//loop runs for 0xFA * 0xFF times.
										//just consumes clock cycles
		   ret							//return from where called
 1be:	08 95       	ret

000001c0 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 1c0:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 1c4:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 1c6:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 1c8:	00 91 13 06 	lds	r16, 0x0613	; 0x800613 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 1cc:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,6					//load 0x06 into r16 ***
 1ce:	06 e0       	ldi	r16, 0x06	; 6
		   out    PORTB,r16				//load 0x06 into the Port B data register ***
 1d0:	05 b9       	out	0x05, r16	; 5
		   call   LCD_Delay				//Delay the LCD with double loop ***
 1d2:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 1d6:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 1d8:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with double loop ***
 1da:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
		   call	  UART_On				//Resume receiving/transmitting
 1de:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
		   ret							//return from where called
 1e2:	08 95       	ret

000001e4 <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 1e4:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
		   ldi    r16,0x00				//clear r16
 1e8:	00 e0       	ldi	r16, 0x00	; 0
		   out    DDRD,r16				//Set PD0-PD7 to input pins
 1ea:	0a b9       	out	0x0a, r16	; 10
		   out    PORTB,4				//Set port B data register to 0x04 ***
 1ec:	45 b8       	out	0x05, r4	; 5
		   in     r16,PORTD				//store data in port D data register into r16
 1ee:	0b b1       	in	r16, 0x0b	; 11
		   sts    DATA,r16				//Store the data in r16 in global variable
 1f0:	00 93 13 06 	sts	0x0613, r16	; 0x800613 <DATA>
		   out    PORTB,0				//clear port B data register ***
 1f4:	05 b8       	out	0x05, r0	; 5
		   call	  UART_On				//Resume receiving/transmitting
 1f6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
		   ret							//return from where called.
 1fa:	08 95       	ret

000001fc <UART_On>:

.global UART_On
UART_On:
		   ldi    r16,2					//set r16 to 2, 00000010
 1fc:	02 e0       	ldi	r16, 0x02	; 2
		   out    DDRD,r16				//Set PD2 as an output
 1fe:	0a b9       	out	0x0a, r16	; 10
		   ldi    r16,24				//load 0x18,00011000, into r16
 200:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 202:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ret							//return from where called.
 206:	08 95       	ret

00000208 <UART_Off>:

.global UART_Off
UART_Off:
		   ldi    r16,0					//Set r16 to 0
 208:	00 e0       	ldi	r16, 0x00	; 0
		   sts    UCSR0B,r16			//clear UCSR0B, effectively shuts down any receiving/transmitting
 20a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		   ret							//return from where called.
 20e:	08 95       	ret

00000210 <UART_Clear>:

.global UART_Clear
UART_Clear:
		   lds    r16,UCSR0A			//set r16 to the UCSR0A
 210:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r16,RXC0				//If bit 7 is high skip.
 214:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   ret							//If RXC0 is 0 than their is no data in the recieve buffer
 216:	08 95       	ret
										//No clear is needed. Return to where called
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 218:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   rjmp   UART_Clear			//Continue into loop until the recieve buffer is empty. 
 21c:	f9 cf       	rjmp	.-14     	; 0x210 <UART_Clear>

0000021e <UART_Get>:

.global UART_Get
UART_Get:
		   lds    r16,UCSR0A			//Set r16 to UCSR0A
 21e:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs   r16,RXC0				//If bit 7 is high skip.
 222:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   rjmp	  UART_Get				//Remain in loop until there is data in the USART Receive Buffer
 224:	fc cf       	rjmp	.-8      	; 0x21e <UART_Get>
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 226:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   sts    ASCII,r16				//load character in the USART data register into ASCII
 22a:	00 93 15 06 	sts	0x0615, r16	; 0x800615 <ASCII>
		   ret							//Return from where called
 22e:	08 95       	ret

00000230 <UART_Get2>:

.global UART_Get2
UART_Get2:
			lds    r16,UCSR0A			//student comment here
 230:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
			ldi	   r18,2
 234:	22 e0       	ldi	r18, 0x02	; 2

00000236 <loop>:
loop:    	dec	   r18
 236:	2a 95       	dec	r18
			brne   loop				    //student comment here
 238:	f1 f7       	brne	.-4      	; 0x236 <loop>
		    lds    r16,UDR0				//student comment here
 23a:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		    sts    test,r16				//student comment here
 23e:	00 93 1e 06 	sts	0x061E, r16	; 0x80061e <test>
		    ret	
 242:	08 95       	ret

00000244 <UART_Put>:

.global UART_Put
UART_Put:
		   lds    r17,UCSR0A			//Set r16 to UCSR0A
 244:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r17,UDRE0				//If bit 5 is high skip.
 248:	15 ff       	sbrs	r17, 5
										//Skips if the transmit buffer is ready to receive new data
		   rjmp	  UART_Put				//Remain in loop until transmit buffer is ready
 24a:	fc cf       	rjmp	.-8      	; 0x244 <UART_Put>
		   lds    r16,ASCII				//Load character in ASCII to r16
 24c:	00 91 15 06 	lds	r16, 0x0615	; 0x800615 <ASCII>
		   sts    UDR0,r16				//Store r16 into the USART data register
 250:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   ret							//return from where called.
 254:	08 95       	ret

00000256 <UART_Get_NoInterrupt>:

.global UART_Get_NoInterrupt
UART_Get_NoInterrupt:
		   lds    r16,UDR0
 256:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   sts    ASCII,r16
 25a:	00 93 15 06 	sts	0x0615, r16	; 0x800615 <ASCII>
		   ret
 25e:	08 95       	ret

00000260 <ADC_Get>:

.global ADC_Get
ADC_Get:
		   ldi    r16,0xC7				//set r16 to 0xC7, 11000111
 260:	07 ec       	ldi	r16, 0xC7	; 199
		   ldi    r17,0x00
 262:	10 e0       	ldi	r17, 0x00	; 0
		   sts    ADCSRB,r17  
 264:	10 93 7b 00 	sts	0x007B, r17	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		   sts    ADCSRA,r16			//Sets bits 7,6,5,2,1,0 of the ADCSRA
 268:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

0000026c <A2V1>:
										//Bits 7 and 6 enable and start the ADC conversion
										//Bit 5 allows the ADC to run in free run mode as long as ADTS[2:0] are set to zero
										//Bits 2-0 Set the division factor to 128
A2V1:	   lds    r16,ADCSRA			//Load ADCSRA to r16
 26c:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		   sbrc	  r16,ADSC				//if bit 6 is low skip
 270:	06 fd       	sbrc	r16, 6
										//Bit 6 or the ADSC is high so long as a conversion is being performed
		   rjmp   A2V1					//Stays in loop so long as conversion is being performed
 272:	fc cf       	rjmp	.-8      	; 0x26c <A2V1>
										//Below stores the result in global variables
		   lds    r16,ADCL				//stores the ADC Register Low into r16
 274:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		   sts    LADC,r16				//stores ADCL in LADC global variable
 278:	00 93 26 06 	sts	0x0626, r16	; 0x800626 <LADC>
		   lds    r16,ADCH				//stores  the ADC Register High into r16
 27c:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		   sts    HADC,r16				//stores ADCH into HADC global variable
 280:	00 93 14 06 	sts	0x0614, r16	; 0x800614 <HADC>
		   ret							//return from where called
 284:	08 95       	ret

00000286 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		   sbic   EECR,EEPE
 286:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Write			; Wait for completion of previous write
 288:	fe cf       	rjmp	.-4      	; 0x286 <EEPROM_Write>
		   lds    r18,EEPROMH			; Set up address (r18:r17) in address register
 28a:	20 91 1d 06 	lds	r18, 0x061D	; 0x80061d <EEPROMH>
		   lds    r17,EEPROML 
 28e:	10 91 27 06 	lds	r17, 0x0627	; 0x800627 <EEPROML>
		   lds    r16,EEPROMV			; Set up data in r16    
 292:	00 91 12 06 	lds	r16, 0x0612	; 0x800612 <EEPROMV>
		   out    EEARH, r18      
 296:	22 bd       	out	0x22, r18	; 34
		   out    EEARL, r17			      
 298:	11 bd       	out	0x21, r17	; 33
		   out    EEDR,r16				; Write data (r16) to Data Register  
 29a:	00 bd       	out	0x20, r16	; 32
		   sbi    EECR,EEMPE			; Write logical one to EEMPE
 29c:	fa 9a       	sbi	0x1f, 2	; 31
		   sbi    EECR,EEPE				; Start eeprom write by setting EEPE
 29e:	f9 9a       	sbi	0x1f, 1	; 31
		   ret 
 2a0:	08 95       	ret

000002a2 <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		   sbic   EECR,EEPE    
 2a2:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Read			; Wait for completion of previous write
 2a4:	fe cf       	rjmp	.-4      	; 0x2a2 <EEPROM_Read>
		   lds    r18,EEPROMH			; Set up address (r18:r17) in EEPROM address register
 2a6:	20 91 1d 06 	lds	r18, 0x061D	; 0x80061d <EEPROMH>
		   lds    r17,EEPROML
 2aa:	10 91 27 06 	lds	r17, 0x0627	; 0x800627 <EEPROML>
		   ldi    r16,0x00   
 2ae:	00 e0       	ldi	r16, 0x00	; 0
		   out    EEARH,r18   
 2b0:	22 bd       	out	0x22, r18	; 34
		   out    EEARL,r17		   
 2b2:	11 bd       	out	0x21, r17	; 33
		   sbi    EECR,EERE				; Start eeprom read by writing EERE
 2b4:	f8 9a       	sbi	0x1f, 0	; 31
		   in     r16,EEDR				; Read data from Data Register
 2b6:	00 b5       	in	r16, 0x20	; 32
		   sts    ASCII,r16  
 2b8:	00 93 15 06 	sts	0x0615, r16	; 0x800615 <ASCII>
		   ret
 2bc:	08 95       	ret

000002be <UART_Puts>:
char temp[7];					//string buffer for ADC output
char lastTemp[7];
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 2be:	cf 93       	push	r28
 2c0:	df 93       	push	r29
 2c2:	ec 01       	movw	r28, r24
	while (*str)                //While the current character is not the null character
 2c4:	98 81       	ld	r25, Y
 2c6:	99 23       	and	r25, r25
 2c8:	41 f0       	breq	.+16     	; 0x2da <UART_Puts+0x1c>
 2ca:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;         
 2cc:	90 93 15 06 	sts	0x0615, r25	; 0x800615 <ASCII>
		UART_Put();
 2d0:	0e 94 22 01 	call	0x244	; 0x244 <UART_Put>
char lastTemp[7];
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)                //While the current character is not the null character
 2d4:	99 91       	ld	r25, Y+
 2d6:	91 11       	cpse	r25, r1
 2d8:	f9 cf       	rjmp	.-14     	; 0x2cc <UART_Puts+0xe>
	{
		ASCII = *str++;         
		UART_Put();
	}
}
 2da:	df 91       	pop	r29
 2dc:	cf 91       	pop	r28
 2de:	08 95       	ret

000002e0 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 2e0:	cf 93       	push	r28
 2e2:	df 93       	push	r29
 2e4:	ec 01       	movw	r28, r24
	while (*str)
 2e6:	98 81       	ld	r25, Y
 2e8:	99 23       	and	r25, r25
 2ea:	41 f0       	breq	.+16     	; 0x2fc <LCD_Puts+0x1c>
 2ec:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 2ee:	90 93 13 06 	sts	0x0613, r25	; 0x800613 <DATA>
		LCD_Write_Data();
 2f2:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 2f6:	99 91       	ld	r25, Y+
 2f8:	91 11       	cpse	r25, r1
 2fa:	f9 cf       	rjmp	.-14     	; 0x2ee <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 2fc:	df 91       	pop	r29
 2fe:	cf 91       	pop	r28
 300:	08 95       	ret

00000302 <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 302:	82 ef       	ldi	r24, 0xF2	; 242
 304:	95 e0       	ldi	r25, 0x05	; 5
 306:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	UART_Puts(MS2);
 30a:	8b eb       	ldi	r24, 0xBB	; 187
 30c:	95 e0       	ldi	r25, 0x05	; 5
 30e:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	UART_Puts(MS4);
 312:	8c e7       	ldi	r24, 0x7C	; 124
 314:	95 e0       	ldi	r25, 0x05	; 5
 316:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
 31a:	08 95       	ret

0000031c <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 31c:	86 e8       	ldi	r24, 0x86	; 134
 31e:	95 e0       	ldi	r25, 0x05	; 5
 320:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
 324:	08 95       	ret

00000326 <LCD>:
}

void LCD(void)						//Lite LCD demo
{
 326:	ff 92       	push	r15
 328:	0f 93       	push	r16
 32a:	1f 93       	push	r17
 32c:	cf 93       	push	r28
 32e:	df 93       	push	r29
 330:	cd b7       	in	r28, 0x3d	; 61
 332:	de b7       	in	r29, 0x3e	; 62
 334:	60 97       	sbiw	r28, 0x10	; 16
 336:	0f b6       	in	r0, 0x3f	; 63
 338:	f8 94       	cli
 33a:	de bf       	out	0x3e, r29	; 62
 33c:	0f be       	out	0x3f, r0	; 63
 33e:	cd bf       	out	0x3d, r28	; 61
	DATA = 0x01;
 340:	81 e0       	ldi	r24, 0x01	; 1
 342:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 346:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x34;					//Student Comment Here
 34a:	84 e3       	ldi	r24, 0x34	; 52
 34c:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 350:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 354:	88 e0       	ldi	r24, 0x08	; 8
 356:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 35a:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 35e:	82 e0       	ldi	r24, 0x02	; 2
 360:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 364:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 368:	86 e0       	ldi	r24, 0x06	; 6
 36a:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 36e:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x0f;					//Student Comment Here
 372:	8f e0       	ldi	r24, 0x0F	; 15
 374:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <DATA>
	LCD_Write_Command();
 378:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	//LCD_Puts("TEAM 9");
	
	test == '\0';
	char Team_Name[16] = "TEAM 9"; 
 37c:	87 e0       	ldi	r24, 0x07	; 7
 37e:	e0 e0       	ldi	r30, 0x00	; 0
 380:	f1 e0       	ldi	r31, 0x01	; 1
 382:	de 01       	movw	r26, r28
 384:	11 96       	adiw	r26, 0x01	; 1
 386:	01 90       	ld	r0, Z+
 388:	0d 92       	st	X+, r0
 38a:	8a 95       	dec	r24
 38c:	e1 f7       	brne	.-8      	; 0x386 <LCD+0x60>
 38e:	fe 01       	movw	r30, r28
 390:	38 96       	adiw	r30, 0x08	; 8
 392:	89 e0       	ldi	r24, 0x09	; 9
 394:	df 01       	movw	r26, r30
 396:	1d 92       	st	X+, r1
 398:	8a 95       	dec	r24
 39a:	e9 f7       	brne	.-6      	; 0x396 <LCD+0x70>
	while (1)				//not entering loop here for some reason
	{
		LCD_Puts(Team_Name);
		for(int i = 0; i < 16; i++)
		{
			DATA = 0x1C;
 39c:	0f 2e       	mov	r0, r31
 39e:	fc e1       	ldi	r31, 0x1C	; 28
 3a0:	ff 2e       	mov	r15, r31
 3a2:	f0 2d       	mov	r31, r0
	
	test == '\0';
	char Team_Name[16] = "TEAM 9"; 
	while (1)				//not entering loop here for some reason
	{
		LCD_Puts(Team_Name);
 3a4:	ce 01       	movw	r24, r28
 3a6:	01 96       	adiw	r24, 0x01	; 1
 3a8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_Puts>
 3ac:	00 e1       	ldi	r16, 0x10	; 16
 3ae:	10 e0       	ldi	r17, 0x00	; 0
		for(int i = 0; i < 16; i++)
		{
			DATA = 0x1C;
 3b0:	f0 92 13 06 	sts	0x0613, r15	; 0x800613 <DATA>
			LCD_Write_Command();
 3b4:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
			LCD_Delay();
 3b8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3bc:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3c0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3c4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3c8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3cc:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3d0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			LCD_Delay();
 3d4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
			
			UART_Get2();
 3d8:	0e 94 18 01 	call	0x230	; 0x230 <UART_Get2>
			if(test != '\0')
 3dc:	80 91 1e 06 	lds	r24, 0x061E	; 0x80061e <test>
 3e0:	88 23       	and	r24, r24
 3e2:	19 f0       	breq	.+6      	; 0x3ea <LCD+0xc4>
			{
				HELP();
 3e4:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
				return;
 3e8:	04 c0       	rjmp	.+8      	; 0x3f2 <LCD+0xcc>
 3ea:	01 50       	subi	r16, 0x01	; 1
 3ec:	11 09       	sbc	r17, r1
	test == '\0';
	char Team_Name[16] = "TEAM 9"; 
	while (1)				//not entering loop here for some reason
	{
		LCD_Puts(Team_Name);
		for(int i = 0; i < 16; i++)
 3ee:	01 f7       	brne	.-64     	; 0x3b0 <LCD+0x8a>
 3f0:	d9 cf       	rjmp	.-78     	; 0x3a4 <LCD+0x7e>
	Re-engineer this subroutine to have the LCD endlessly scroll a marquee sign of 
	your Team's name either vertically or horizontally. Any key press should stop
	the scrolling and return execution to the command line in Terminal. User must
	always be able to return to command line.
	*/
}
 3f2:	60 96       	adiw	r28, 0x10	; 16
 3f4:	0f b6       	in	r0, 0x3f	; 63
 3f6:	f8 94       	cli
 3f8:	de bf       	out	0x3e, r29	; 62
 3fa:	0f be       	out	0x3f, r0	; 63
 3fc:	cd bf       	out	0x3d, r28	; 61
 3fe:	df 91       	pop	r29
 400:	cf 91       	pop	r28
 402:	1f 91       	pop	r17
 404:	0f 91       	pop	r16
 406:	ff 90       	pop	r15
 408:	08 95       	ret

0000040a <ADC>:

void ADC(void)                        //Lite Demo of the Analog to Digital Converter
{
 40a:	8f 92       	push	r8
 40c:	9f 92       	push	r9
 40e:	af 92       	push	r10
 410:	bf 92       	push	r11
 412:	cf 92       	push	r12
 414:	df 92       	push	r13
 416:	ef 92       	push	r14
 418:	ff 92       	push	r15
 41a:	1f 93       	push	r17
 41c:	cf 93       	push	r28
 41e:	df 93       	push	r29
    //test = 1;
    
    ADC_Get();
 420:	0e 94 30 01 	call	0x260	; 0x260 <ADC_Get>
    double kelvin = 0;
    int fahrenheit = 0;
	const double t0 = 295.37;
	const double B = 3950.0;
    
    Acc = (((int)HADC) * 0x100 + (int)(LADC));
 424:	60 91 14 06 	lds	r22, 0x0614	; 0x800614 <HADC>
 428:	70 e0       	ldi	r23, 0x00	; 0
 42a:	76 2f       	mov	r23, r22
 42c:	66 27       	eor	r22, r22
 42e:	80 91 26 06 	lds	r24, 0x0626	; 0x800626 <LADC>
 432:	68 0f       	add	r22, r24
 434:	71 1d       	adc	r23, r1
 436:	70 93 29 06 	sts	0x0629, r23	; 0x800629 <Acc+0x1>
 43a:	60 93 28 06 	sts	0x0628, r22	; 0x800628 <Acc>
    double r = (10000.0 * ((double)Acc))/(1024.0 - ((double)Acc));
 43e:	07 2e       	mov	r0, r23
 440:	00 0c       	add	r0, r0
 442:	88 0b       	sbc	r24, r24
 444:	99 0b       	sbc	r25, r25
 446:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 44a:	6b 01       	movw	r12, r22
 44c:	7c 01       	movw	r14, r24
 44e:	20 e0       	ldi	r18, 0x00	; 0
 450:	30 e4       	ldi	r19, 0x40	; 64
 452:	4c e1       	ldi	r20, 0x1C	; 28
 454:	56 e4       	ldi	r21, 0x46	; 70
 456:	0e 94 27 07 	call	0xe4e	; 0xe4e <__mulsf3>
 45a:	4b 01       	movw	r8, r22
 45c:	5c 01       	movw	r10, r24
 45e:	a7 01       	movw	r20, r14
 460:	96 01       	movw	r18, r12
 462:	60 e0       	ldi	r22, 0x00	; 0
 464:	70 e0       	ldi	r23, 0x00	; 0
 466:	80 e8       	ldi	r24, 0x80	; 128
 468:	94 e4       	ldi	r25, 0x44	; 68
 46a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <__subsf3>
 46e:	9b 01       	movw	r18, r22
 470:	ac 01       	movw	r20, r24
 472:	c5 01       	movw	r24, r10
 474:	b4 01       	movw	r22, r8
 476:	0e 94 49 05 	call	0xa92	; 0xa92 <__divsf3>
    double r0 = ((double)10000 * (double)512)/((double)1024 - (double)512);
    r = r/r0;
    
    kelvin = (B * t0)/(t0 * log(r) + B);
 47a:	20 e0       	ldi	r18, 0x00	; 0
 47c:	30 e4       	ldi	r19, 0x40	; 64
 47e:	4c e1       	ldi	r20, 0x1C	; 28
 480:	56 e4       	ldi	r21, 0x46	; 70
 482:	0e 94 49 05 	call	0xa92	; 0xa92 <__divsf3>
 486:	0e 94 df 06 	call	0xdbe	; 0xdbe <log>

    celsius = kelvin - 273.15;
    
    fahrenheit = 10 * (celsius*(9.0/5.0) + 1);
 48a:	2c e5       	ldi	r18, 0x5C	; 92
 48c:	3f ea       	ldi	r19, 0xAF	; 175
 48e:	43 e9       	ldi	r20, 0x93	; 147
 490:	53 e4       	ldi	r21, 0x43	; 67
 492:	0e 94 27 07 	call	0xe4e	; 0xe4e <__mulsf3>
 496:	20 e0       	ldi	r18, 0x00	; 0
 498:	30 ee       	ldi	r19, 0xE0	; 224
 49a:	46 e7       	ldi	r20, 0x76	; 118
 49c:	55 e4       	ldi	r21, 0x45	; 69
 49e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 4a2:	9b 01       	movw	r18, r22
 4a4:	ac 01       	movw	r20, r24
 4a6:	6c eb       	ldi	r22, 0xBC	; 188
 4a8:	7b e6       	ldi	r23, 0x6B	; 107
 4aa:	8e e8       	ldi	r24, 0x8E	; 142
 4ac:	99 e4       	ldi	r25, 0x49	; 73
 4ae:	0e 94 49 05 	call	0xa92	; 0xa92 <__divsf3>
 4b2:	23 e3       	ldi	r18, 0x33	; 51
 4b4:	33 e9       	ldi	r19, 0x93	; 147
 4b6:	48 e8       	ldi	r20, 0x88	; 136
 4b8:	53 e4       	ldi	r21, 0x43	; 67
 4ba:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <__subsf3>
 4be:	26 e6       	ldi	r18, 0x66	; 102
 4c0:	36 e6       	ldi	r19, 0x66	; 102
 4c2:	46 ee       	ldi	r20, 0xE6	; 230
 4c4:	5f e3       	ldi	r21, 0x3F	; 63
 4c6:	0e 94 27 07 	call	0xe4e	; 0xe4e <__mulsf3>
 4ca:	20 e0       	ldi	r18, 0x00	; 0
 4cc:	30 e0       	ldi	r19, 0x00	; 0
 4ce:	40 e8       	ldi	r20, 0x80	; 128
 4d0:	5f e3       	ldi	r21, 0x3F	; 63
 4d2:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 4d6:	20 e0       	ldi	r18, 0x00	; 0
 4d8:	30 e0       	ldi	r19, 0x00	; 0
 4da:	40 e2       	ldi	r20, 0x20	; 32
 4dc:	51 e4       	ldi	r21, 0x41	; 65
 4de:	0e 94 27 07 	call	0xe4e	; 0xe4e <__mulsf3>
 4e2:	0e 94 bb 05 	call	0xb76	; 0xb76 <__fixsfsi>
    
    char f0 = floor((fahrenheit/1000)) + '0';
 4e6:	cb 01       	movw	r24, r22
 4e8:	68 ee       	ldi	r22, 0xE8	; 232
 4ea:	73 e0       	ldi	r23, 0x03	; 3
 4ec:	0e 94 bb 07 	call	0xf76	; 0xf76 <__divmodhi4>
 4f0:	ec 01       	movw	r28, r24
 4f2:	07 2e       	mov	r0, r23
 4f4:	00 0c       	add	r0, r0
 4f6:	88 0b       	sbc	r24, r24
 4f8:	99 0b       	sbc	r25, r25
 4fa:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 4fe:	0e 94 2e 06 	call	0xc5c	; 0xc5c <floor>
 502:	20 e0       	ldi	r18, 0x00	; 0
 504:	30 e0       	ldi	r19, 0x00	; 0
 506:	40 e4       	ldi	r20, 0x40	; 64
 508:	52 e4       	ldi	r21, 0x42	; 66
 50a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 50e:	0e 94 c2 05 	call	0xb84	; 0xb84 <__fixunssfsi>
 512:	16 2f       	mov	r17, r22
    fahrenheit = fahrenheit % 1000;
    char f1 = floor((fahrenheit/100)) + '0';
 514:	ce 01       	movw	r24, r28
 516:	64 e6       	ldi	r22, 0x64	; 100
 518:	70 e0       	ldi	r23, 0x00	; 0
 51a:	0e 94 bb 07 	call	0xf76	; 0xf76 <__divmodhi4>
 51e:	ec 01       	movw	r28, r24
 520:	07 2e       	mov	r0, r23
 522:	00 0c       	add	r0, r0
 524:	88 0b       	sbc	r24, r24
 526:	99 0b       	sbc	r25, r25
 528:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 52c:	0e 94 2e 06 	call	0xc5c	; 0xc5c <floor>
 530:	20 e0       	ldi	r18, 0x00	; 0
 532:	30 e0       	ldi	r19, 0x00	; 0
 534:	40 e4       	ldi	r20, 0x40	; 64
 536:	52 e4       	ldi	r21, 0x42	; 66
 538:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 53c:	0e 94 c2 05 	call	0xb84	; 0xb84 <__fixunssfsi>
 540:	e6 2e       	mov	r14, r22
    fahrenheit = fahrenheit % 100;
    char f2 = floor(fahrenheit/10) + '0';
 542:	ce 01       	movw	r24, r28
 544:	6a e0       	ldi	r22, 0x0A	; 10
 546:	70 e0       	ldi	r23, 0x00	; 0
 548:	0e 94 bb 07 	call	0xf76	; 0xf76 <__divmodhi4>
 54c:	ec 01       	movw	r28, r24
 54e:	07 2e       	mov	r0, r23
 550:	00 0c       	add	r0, r0
 552:	88 0b       	sbc	r24, r24
 554:	99 0b       	sbc	r25, r25
 556:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 55a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <floor>
 55e:	20 e0       	ldi	r18, 0x00	; 0
 560:	30 e0       	ldi	r19, 0x00	; 0
 562:	40 e4       	ldi	r20, 0x40	; 64
 564:	52 e4       	ldi	r21, 0x42	; 66
 566:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 56a:	0e 94 c2 05 	call	0xb84	; 0xb84 <__fixunssfsi>
 56e:	f6 2e       	mov	r15, r22
    fahrenheit = fahrenheit % 10;
    char f3 = floor(fahrenheit) + '0';
 570:	be 01       	movw	r22, r28
 572:	dd 0f       	add	r29, r29
 574:	88 0b       	sbc	r24, r24
 576:	99 0b       	sbc	r25, r25
 578:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 57c:	0e 94 2e 06 	call	0xc5c	; 0xc5c <floor>
 580:	20 e0       	ldi	r18, 0x00	; 0
 582:	30 e0       	ldi	r19, 0x00	; 0
 584:	40 e4       	ldi	r20, 0x40	; 64
 586:	52 e4       	ldi	r21, 0x42	; 66
 588:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 58c:	0e 94 c2 05 	call	0xb84	; 0xb84 <__fixunssfsi>
    
    if(f0 == '0'){
 590:	10 33       	cpi	r17, 0x30	; 48
 592:	09 f4       	brne	.+2      	; 0x596 <ADC+0x18c>
        f0 = ' ';
 594:	10 e2       	ldi	r17, 0x20	; 32
    }
    
    temp[0] = f0;
 596:	e6 e1       	ldi	r30, 0x16	; 22
 598:	f6 e0       	ldi	r31, 0x06	; 6
 59a:	10 83       	st	Z, r17
    temp[1] = f1;
 59c:	e1 82       	std	Z+1, r14	; 0x01
    temp[2] = f2;
 59e:	f2 82       	std	Z+2, r15	; 0x02
    temp[3] = 46;
 5a0:	8e e2       	ldi	r24, 0x2E	; 46
 5a2:	83 83       	std	Z+3, r24	; 0x03
    temp[4] = f3;
 5a4:	64 83       	std	Z+4, r22	; 0x04
    temp[5] = 167;
 5a6:	87 ea       	ldi	r24, 0xA7	; 167
 5a8:	85 83       	std	Z+5, r24	; 0x05
    temp[6] = 0;
 5aa:	16 82       	std	Z+6, r1	; 0x06
    
    if(strcmp(lastTemp, temp) != 0){
 5ac:	bf 01       	movw	r22, r30
 5ae:	8f e1       	ldi	r24, 0x1F	; 31
 5b0:	96 e0       	ldi	r25, 0x06	; 6
 5b2:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <strcmp>
 5b6:	89 2b       	or	r24, r25
 5b8:	91 f0       	breq	.+36     	; 0x5de <ADC+0x1d4>
        
        UART_Puts("          \r");
 5ba:	80 e1       	ldi	r24, 0x10	; 16
 5bc:	91 e0       	ldi	r25, 0x01	; 1
 5be:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
        UART_Puts(temp);
 5c2:	86 e1       	ldi	r24, 0x16	; 22
 5c4:	96 e0       	ldi	r25, 0x06	; 6
 5c6:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
        UART_Puts(" F\r");
 5ca:	8c e1       	ldi	r24, 0x1C	; 28
 5cc:	91 e0       	ldi	r25, 0x01	; 1
 5ce:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
        
        strcpy(lastTemp, temp);
 5d2:	66 e1       	ldi	r22, 0x16	; 22
 5d4:	76 e0       	ldi	r23, 0x06	; 6
 5d6:	8f e1       	ldi	r24, 0x1F	; 31
 5d8:	96 e0       	ldi	r25, 0x06	; 6
 5da:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <strcpy>
    }
    
    LCD_Delay();
 5de:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
    LCD_Delay();
 5e2:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
    LCD_Delay();
 5e6:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
    LCD_Delay();
 5ea:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
    
    UART_Get_NoInterrupt();
 5ee:	0e 94 2b 01 	call	0x256	; 0x256 <UART_Get_NoInterrupt>
    
    if((ASCII == 'x')){ 
 5f2:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 5f6:	88 37       	cpi	r24, 0x78	; 120
 5f8:	91 f4       	brne	.+36     	; 0x61e <ADC+0x214>
        //test = 0;
        strcpy(lastTemp, "     ");
 5fa:	86 e0       	ldi	r24, 0x06	; 6
 5fc:	e0 e2       	ldi	r30, 0x20	; 32
 5fe:	f1 e0       	ldi	r31, 0x01	; 1
 600:	af e1       	ldi	r26, 0x1F	; 31
 602:	b6 e0       	ldi	r27, 0x06	; 6
 604:	01 90       	ld	r0, Z+
 606:	0d 92       	st	X+, r0
 608:	8a 95       	dec	r24
 60a:	e1 f7       	brne	.-8      	; 0x604 <ADC+0x1fa>
        strcpy(temp, "     ");
 60c:	86 e0       	ldi	r24, 0x06	; 6
 60e:	e0 e2       	ldi	r30, 0x20	; 32
 610:	f1 e0       	ldi	r31, 0x01	; 1
 612:	a6 e1       	ldi	r26, 0x16	; 22
 614:	b6 e0       	ldi	r27, 0x06	; 6
 616:	01 90       	ld	r0, Z+
 618:	0d 92       	st	X+, r0
 61a:	8a 95       	dec	r24
 61c:	e1 f7       	brne	.-8      	; 0x616 <ADC+0x20c>
        The potentiometer simulates a thermistor, its varying resistance simulates the
        varying resistance of a thermistor as it is heated and cooled. See the thermistor
        equations in the lab 3 folder. User must always be able to return to command line.
    */
    return;
}
 61e:	df 91       	pop	r29
 620:	cf 91       	pop	r28
 622:	1f 91       	pop	r17
 624:	ff 90       	pop	r15
 626:	ef 90       	pop	r14
 628:	df 90       	pop	r13
 62a:	cf 90       	pop	r12
 62c:	bf 90       	pop	r11
 62e:	af 90       	pop	r10
 630:	9f 90       	pop	r9
 632:	8f 90       	pop	r8
 634:	08 95       	ret

00000636 <writeEEPROM>:


void writeEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be written to\r\n");
 636:	86 e2       	ldi	r24, 0x26	; 38
 638:	91 e0       	ldi	r25, 0x01	; 1
 63a:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 63e:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 642:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>


void writeEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be written to\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 646:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 64a:	88 23       	and	r24, r24
 64c:	d1 f3       	breq	.-12     	; 0x642 <writeEEPROM+0xc>
		
		UART_Get();
	}
	EEPROMH = ASCII;
 64e:	80 93 1d 06 	sts	0x061D, r24	; 0x80061d <EEPROMH>
	UART_Puts("\r\nEnter the least significant bit of the address to be written to\r\n");
 652:	89 e6       	ldi	r24, 0x69	; 105
 654:	91 e0       	ldi	r25, 0x01	; 1
 656:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 65a:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 65e:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
		UART_Get();
	}
	EEPROMH = ASCII;
	UART_Puts("\r\nEnter the least significant bit of the address to be written to\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 662:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 666:	88 23       	and	r24, r24
 668:	d1 f3       	breq	.-12     	; 0x65e <writeEEPROM+0x28>
		
		UART_Get();
	}
	EEPROML = ASCII;
 66a:	80 93 27 06 	sts	0x0627, r24	; 0x800627 <EEPROML>
	UART_Puts("\r\nEnter an 8 bit value to store\r\n");
 66e:	8d ea       	ldi	r24, 0xAD	; 173
 670:	91 e0       	ldi	r25, 0x01	; 1
 672:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 676:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 67a:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
		UART_Get();
	}
	EEPROML = ASCII;
	UART_Puts("\r\nEnter an 8 bit value to store\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 67e:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 682:	88 23       	and	r24, r24
 684:	d1 f3       	breq	.-12     	; 0x67a <writeEEPROM+0x44>
		
		UART_Get();
	}
	EEPROMV = ASCII;
 686:	80 93 12 06 	sts	0x0612, r24	; 0x800612 <EEPROMV>
	EEPROM_Write();
 68a:	0e 94 43 01 	call	0x286	; 0x286 <EEPROM_Write>
	UART_Puts("\r\nThe data has been stored in EEPROM");
 68e:	8f ec       	ldi	r24, 0xCF	; 207
 690:	91 e0       	ldi	r25, 0x01	; 1
 692:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
 696:	08 95       	ret

00000698 <readEEPROM>:
	
}

void readEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be read\r\n");
 698:	84 ef       	ldi	r24, 0xF4	; 244
 69a:	91 e0       	ldi	r25, 0x01	; 1
 69c:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 6a0:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 6a4:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
}

void readEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be read\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 6a8:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 6ac:	88 23       	and	r24, r24
 6ae:	d1 f3       	breq	.-12     	; 0x6a4 <readEEPROM+0xc>
		
		UART_Get();
	}
	EEPROMH = ASCII;
 6b0:	80 93 1d 06 	sts	0x061D, r24	; 0x80061d <EEPROMH>
	UART_Puts("\r\nEnter the least significant bit of the address to be read\r\n");
 6b4:	81 e3       	ldi	r24, 0x31	; 49
 6b6:	92 e0       	ldi	r25, 0x02	; 2
 6b8:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 6bc:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 6c0:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
		UART_Get();
	}
	EEPROMH = ASCII;
	UART_Puts("\r\nEnter the least significant bit of the address to be read\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 6c4:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 6c8:	88 23       	and	r24, r24
 6ca:	d1 f3       	breq	.-12     	; 0x6c0 <readEEPROM+0x28>
		
		UART_Get();
	}
	EEPROML = ASCII;
 6cc:	80 93 27 06 	sts	0x0627, r24	; 0x800627 <EEPROML>
	EEPROM_Read();
 6d0:	0e 94 51 01 	call	0x2a2	; 0x2a2 <EEPROM_Read>
	UART_Put();
 6d4:	0e 94 22 01 	call	0x244	; 0x244 <UART_Put>
	UART_Puts("\r\nThe data has been stored in EEPROM");
 6d8:	8f ec       	ldi	r24, 0xCF	; 207
 6da:	91 e0       	ldi	r25, 0x01	; 1
 6dc:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
 6e0:	08 95       	ret

000006e2 <EEPROM>:
}

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM (W)rite or (R)Read.\r\n");
 6e2:	8f e6       	ldi	r24, 0x6F	; 111
 6e4:	92 e0       	ldi	r25, 0x02	; 2
 6e6:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 6ea:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 6ee:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM (W)rite or (R)Read.\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 6f2:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 6f6:	88 23       	and	r24, r24
 6f8:	d1 f3       	breq	.-12     	; 0x6ee <EEPROM+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 6fa:	82 37       	cpi	r24, 0x72	; 114
 6fc:	29 f0       	breq	.+10     	; 0x708 <EEPROM+0x26>
 6fe:	87 37       	cpi	r24, 0x77	; 119
 700:	31 f4       	brne	.+12     	; 0x70e <EEPROM+0x2c>
		
		case 'W' | 'w': writeEEPROM();
 702:	0e 94 1b 03 	call	0x636	; 0x636 <writeEEPROM>
		break;
 706:	08 95       	ret
		case 'R' | 'r': readEEPROM();
 708:	0e 94 4c 03 	call	0x698	; 0x698 <readEEPROM>
		break;
 70c:	08 95       	ret
		default:
		UART_Puts(MS5);
 70e:	8d e5       	ldi	r24, 0x5D	; 93
 710:	95 e0       	ldi	r25, 0x05	; 5
 712:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 716:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 71a:	08 95       	ret

0000071c <setBaud>:
}



void setBaud(int i){         //Helper function that changes the baud rate
	UBRRValue = i;			 //Set UBBRBalue to preferred baud rate
 71c:	80 93 10 06 	sts	0x0610, r24	; 0x800610 <__data_end>
 720:	90 93 11 06 	sts	0x0611, r25	; 0x800611 <__data_end+0x1>
	UBRR0L = (unsigned char) UBRRValue;		   //The rest of the baud rate goes here.
 724:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UBRR0H = (unsigned char) (UBRRValue >> 8); //Upper four bits of the baud rate go here.
 728:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 72c:	08 95       	ret

0000072e <baudRouter>:
	
	
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
 72e:	8e e8       	ldi	r24, 0x8E	; 142
 730:	92 e0       	ldi	r25, 0x02	; 2
 732:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 736:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 73a:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 73e:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 742:	88 23       	and	r24, r24
 744:	d1 f3       	breq	.-12     	; 0x73a <baudRouter+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 746:	83 33       	cpi	r24, 0x33	; 51
 748:	e9 f0       	breq	.+58     	; 0x784 <baudRouter+0x56>
 74a:	28 f4       	brcc	.+10     	; 0x756 <baudRouter+0x28>
 74c:	81 33       	cpi	r24, 0x31	; 49
 74e:	41 f0       	breq	.+16     	; 0x760 <baudRouter+0x32>
 750:	82 33       	cpi	r24, 0x32	; 50
 752:	79 f0       	breq	.+30     	; 0x772 <baudRouter+0x44>
 754:	32 c0       	rjmp	.+100    	; 0x7ba <baudRouter+0x8c>
 756:	84 33       	cpi	r24, 0x34	; 52
 758:	f1 f0       	breq	.+60     	; 0x796 <baudRouter+0x68>
 75a:	85 33       	cpi	r24, 0x35	; 53
 75c:	29 f1       	breq	.+74     	; 0x7a8 <baudRouter+0x7a>
 75e:	2d c0       	rjmp	.+90     	; 0x7ba <baudRouter+0x8c>
		
		case '1': setBaud(103);
 760:	87 e6       	ldi	r24, 0x67	; 103
 762:	90 e0       	ldi	r25, 0x00	; 0
 764:	0e 94 8e 03 	call	0x71c	; 0x71c <setBaud>
		UART_Puts("\r\nBaud rate = 9600.\r\n");
 768:	81 ee       	ldi	r24, 0xE1	; 225
 76a:	92 e0       	ldi	r25, 0x02	; 2
 76c:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 770:	08 95       	ret
		case '2': setBaud(68);
 772:	84 e4       	ldi	r24, 0x44	; 68
 774:	90 e0       	ldi	r25, 0x00	; 0
 776:	0e 94 8e 03 	call	0x71c	; 0x71c <setBaud>
		UART_Puts("\r\nBaud rate = 14400\r\n");
 77a:	87 ef       	ldi	r24, 0xF7	; 247
 77c:	92 e0       	ldi	r25, 0x02	; 2
 77e:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 782:	08 95       	ret
		case '3': setBaud(51);
 784:	83 e3       	ldi	r24, 0x33	; 51
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	0e 94 8e 03 	call	0x71c	; 0x71c <setBaud>
		UART_Puts("\r\nBaud rate = 19200\r\n");
 78c:	8d e0       	ldi	r24, 0x0D	; 13
 78e:	93 e0       	ldi	r25, 0x03	; 3
 790:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 794:	08 95       	ret
		case '4': setBaud(34);
 796:	82 e2       	ldi	r24, 0x22	; 34
 798:	90 e0       	ldi	r25, 0x00	; 0
 79a:	0e 94 8e 03 	call	0x71c	; 0x71c <setBaud>
		UART_Puts("\r\nBaud rate = 28800\r\n");
 79e:	83 e2       	ldi	r24, 0x23	; 35
 7a0:	93 e0       	ldi	r25, 0x03	; 3
 7a2:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 7a6:	08 95       	ret
		case '5': setBaud(25);
 7a8:	89 e1       	ldi	r24, 0x19	; 25
 7aa:	90 e0       	ldi	r25, 0x00	; 0
 7ac:	0e 94 8e 03 	call	0x71c	; 0x71c <setBaud>
		UART_Puts("\r\nBaud rate = 38400\r\n");
 7b0:	89 e3       	ldi	r24, 0x39	; 57
 7b2:	93 e0       	ldi	r25, 0x03	; 3
 7b4:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 7b8:	08 95       	ret
		default:
		UART_Puts(MS5);
 7ba:	8d e5       	ldi	r24, 0x5D	; 93
 7bc:	95 e0       	ldi	r25, 0x05	; 5
 7be:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 7c2:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 7c6:	08 95       	ret

000007c8 <setDataBitNum>:
		break;
	}
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
 7c8:	8f e4       	ldi	r24, 0x4F	; 79
 7ca:	93 e0       	ldi	r25, 0x03	; 3
 7cc:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 7d0:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 7d4:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 7d8:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 7dc:	88 23       	and	r24, r24
 7de:	d1 f3       	breq	.-12     	; 0x7d4 <setDataBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 7e0:	87 33       	cpi	r24, 0x37	; 55
 7e2:	a9 f0       	breq	.+42     	; 0x80e <setDataBitNum+0x46>
 7e4:	28 f4       	brcc	.+10     	; 0x7f0 <setDataBitNum+0x28>
 7e6:	85 33       	cpi	r24, 0x35	; 53
 7e8:	41 f0       	breq	.+16     	; 0x7fa <setDataBitNum+0x32>
 7ea:	86 33       	cpi	r24, 0x36	; 54
 7ec:	59 f0       	breq	.+22     	; 0x804 <setDataBitNum+0x3c>
 7ee:	2d c0       	rjmp	.+90     	; 0x84a <setDataBitNum+0x82>
 7f0:	88 33       	cpi	r24, 0x38	; 56
 7f2:	91 f0       	breq	.+36     	; 0x818 <setDataBitNum+0x50>
 7f4:	89 33       	cpi	r24, 0x39	; 57
 7f6:	d1 f0       	breq	.+52     	; 0x82c <setDataBitNum+0x64>
 7f8:	28 c0       	rjmp	.+80     	; 0x84a <setDataBitNum+0x82>
		
		case '5':
		UCSR0C |= (0<<2)&&(0<<1); //if the bits 2-0 of UCSR0C == 000
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 5\r\n");
 7fa:	8e e8       	ldi	r24, 0x8E	; 142
 7fc:	93 e0       	ldi	r25, 0x03	; 3
 7fe:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 802:	08 95       	ret
		case '6':
		UCSR0C |= (0<<2)&&(1<<1); //if bits 2-0 of UCSR0C == 001
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 6\r\n");
 804:	85 ea       	ldi	r24, 0xA5	; 165
 806:	93 e0       	ldi	r25, 0x03	; 3
 808:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 80c:	08 95       	ret
		case '7':
		UCSR0C |= (1<<2)&&(0<<1); //if bits 2-0 of UCSr0C == 010
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 7\r\n");
 80e:	8c eb       	ldi	r24, 0xBC	; 188
 810:	93 e0       	ldi	r25, 0x03	; 3
 812:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 816:	08 95       	ret
		case '8':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 011
 818:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 81c:	81 60       	ori	r24, 0x01	; 1
 81e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 8\r\n");
 822:	83 ed       	ldi	r24, 0xD3	; 211
 824:	93 e0       	ldi	r25, 0x03	; 3
 826:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 82a:	08 95       	ret
		case '9':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 111
 82c:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 830:	81 60       	ori	r24, 0x01	; 1
 832:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (1<<2);
 836:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 83a:	84 60       	ori	r24, 0x04	; 4
 83c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		UART_Puts("\r\n# of Data Bits = 9\r\n");
 840:	8a ee       	ldi	r24, 0xEA	; 234
 842:	93 e0       	ldi	r25, 0x03	; 3
 844:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 848:	08 95       	ret
		default:
		UART_Puts(MS5);
 84a:	8d e5       	ldi	r24, 0x5D	; 93
 84c:	95 e0       	ldi	r25, 0x05	; 5
 84e:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 852:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 856:	08 95       	ret

00000858 <setParity>:
		break;
	}
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
 858:	81 e0       	ldi	r24, 0x01	; 1
 85a:	94 e0       	ldi	r25, 0x04	; 4
 85c:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 860:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 864:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 868:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 86c:	88 23       	and	r24, r24
 86e:	d1 f3       	breq	.-12     	; 0x864 <setParity+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 870:	8e 36       	cpi	r24, 0x6E	; 110
 872:	29 f0       	breq	.+10     	; 0x87e <setParity+0x26>
 874:	8f 36       	cpi	r24, 0x6F	; 111
 876:	41 f0       	breq	.+16     	; 0x888 <setParity+0x30>
 878:	85 36       	cpi	r24, 0x65	; 101
 87a:	a9 f4       	brne	.+42     	; 0x8a6 <setParity+0x4e>
 87c:	0f c0       	rjmp	.+30     	; 0x89c <setParity+0x44>
		
		case 'N' | 'n':
		UCSR0C |= (0<<5)&&(0<<4);
		UART_Puts("\r\nParity = No Parity\r\n");
 87e:	82 e5       	ldi	r24, 0x52	; 82
 880:	94 e0       	ldi	r25, 0x04	; 4
 882:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 886:	08 95       	ret
		case 'O' | 'o':
		UCSR0C |= (1<<5)&&(1<<4);
 888:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 88c:	81 60       	ori	r24, 0x01	; 1
 88e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\nParity = Odd Parity\r\n");
 892:	89 e6       	ldi	r24, 0x69	; 105
 894:	94 e0       	ldi	r25, 0x04	; 4
 896:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 89a:	08 95       	ret
		case 'E' | 'e':
		UCSR0C |= (1<<5)&&(0<<4);
		UART_Puts("\r\nParity = Even Parity\r\n");
 89c:	81 e8       	ldi	r24, 0x81	; 129
 89e:	94 e0       	ldi	r25, 0x04	; 4
 8a0:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 8a4:	08 95       	ret
		default:
		UART_Puts(MS5);
 8a6:	8d e5       	ldi	r24, 0x5D	; 93
 8a8:	95 e0       	ldi	r25, 0x05	; 5
 8aa:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 8ae:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 8b2:	08 95       	ret

000008b4 <setStopBitNum>:
		break;
	}
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
 8b4:	8a e9       	ldi	r24, 0x9A	; 154
 8b6:	94 e0       	ldi	r25, 0x04	; 4
 8b8:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 8bc:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 8c0:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 8c4:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 8c8:	88 23       	and	r24, r24
 8ca:	d1 f3       	breq	.-12     	; 0x8c0 <setStopBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 8cc:	81 33       	cpi	r24, 0x31	; 49
 8ce:	19 f0       	breq	.+6      	; 0x8d6 <setStopBitNum+0x22>
 8d0:	82 33       	cpi	r24, 0x32	; 50
 8d2:	31 f0       	breq	.+12     	; 0x8e0 <setStopBitNum+0x2c>
 8d4:	0f c0       	rjmp	.+30     	; 0x8f4 <setStopBitNum+0x40>
		
		case '1':
		UCSR0C |= (0<<3);
		UART_Puts("\r\n# of Stop Bits = 1\r\n");
 8d6:	86 ed       	ldi	r24, 0xD6	; 214
 8d8:	94 e0       	ldi	r25, 0x04	; 4
 8da:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 8de:	08 95       	ret
		case '2':
		UCSR0C |= (1<<3);
 8e0:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 8e4:	88 60       	ori	r24, 0x08	; 8
 8e6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\n# of Stop Bits = 2\r\n");
 8ea:	8d ee       	ldi	r24, 0xED	; 237
 8ec:	94 e0       	ldi	r25, 0x04	; 4
 8ee:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		break;
 8f2:	08 95       	ret
		default:
		UART_Puts(MS5);
 8f4:	8d e5       	ldi	r24, 0x5D	; 93
 8f6:	95 e0       	ldi	r25, 0x05	; 5
 8f8:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 8fc:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 900:	08 95       	ret

00000902 <Params>:
	}
}

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
 902:	84 e0       	ldi	r24, 0x04	; 4
 904:	95 e0       	ldi	r25, 0x05	; 5
 906:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';
 90a:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 90e:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
	ASCII = '\0';
	while(ASCII == '\0'){
 912:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 916:	88 23       	and	r24, r24
 918:	d1 f3       	breq	.-12     	; 0x90e <Params+0xc>
		
		UART_Get();
	}
	switch(ASCII){                  //For each parameter change send to another router which handles setting the parameter.
 91a:	84 36       	cpi	r24, 0x64	; 100
 91c:	61 f0       	breq	.+24     	; 0x936 <Params+0x34>
 91e:	18 f4       	brcc	.+6      	; 0x926 <Params+0x24>
 920:	82 36       	cpi	r24, 0x62	; 98
 922:	31 f0       	breq	.+12     	; 0x930 <Params+0x2e>
 924:	11 c0       	rjmp	.+34     	; 0x948 <Params+0x46>
 926:	80 37       	cpi	r24, 0x70	; 112
 928:	49 f0       	breq	.+18     	; 0x93c <Params+0x3a>
 92a:	83 37       	cpi	r24, 0x73	; 115
 92c:	51 f0       	breq	.+20     	; 0x942 <Params+0x40>
 92e:	0c c0       	rjmp	.+24     	; 0x948 <Params+0x46>
		
		case 'B' | 'b': baudRouter();
 930:	0e 94 97 03 	call	0x72e	; 0x72e <baudRouter>
		break;
 934:	08 95       	ret
		case 'D' | 'd': setDataBitNum();
 936:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <setDataBitNum>
		break;
 93a:	08 95       	ret
		case 'P' | 'p': setParity();
 93c:	0e 94 2c 04 	call	0x858	; 0x858 <setParity>
		break;
 940:	08 95       	ret
		case 'S' | 's': setStopBitNum();
 942:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <setStopBitNum>
		break;
 946:	08 95       	ret
		default:
		UART_Puts(MS5);
 948:	8d e5       	ldi	r24, 0x5D	; 93
 94a:	95 e0       	ldi	r25, 0x05	; 5
 94c:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 950:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 954:	08 95       	ret

00000956 <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 956:	86 e8       	ldi	r24, 0x86	; 134
 958:	95 e0       	ldi	r25, 0x05	; 5
 95a:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
	ASCII = '\0';						
 95e:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 962:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 966:	80 91 15 06 	lds	r24, 0x0615	; 0x800615 <ASCII>
 96a:	88 23       	and	r24, r24
 96c:	d1 f3       	breq	.-12     	; 0x962 <Command+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 96e:	85 36       	cpi	r24, 0x65	; 101
 970:	79 f0       	breq	.+30     	; 0x990 <Command+0x3a>
 972:	18 f4       	brcc	.+6      	; 0x97a <Command+0x24>
 974:	81 36       	cpi	r24, 0x61	; 97
 976:	49 f0       	breq	.+18     	; 0x98a <Command+0x34>
 978:	11 c0       	rjmp	.+34     	; 0x99c <Command+0x46>
 97a:	8c 36       	cpi	r24, 0x6C	; 108
 97c:	19 f0       	breq	.+6      	; 0x984 <Command+0x2e>
 97e:	85 37       	cpi	r24, 0x75	; 117
 980:	51 f0       	breq	.+20     	; 0x996 <Command+0x40>
 982:	0c c0       	rjmp	.+24     	; 0x99c <Command+0x46>
	{
		case 'L' | 'l': LCD();
 984:	0e 94 93 01 	call	0x326	; 0x326 <LCD>
		break;
 988:	08 95       	ret
		case 'A' | 'a': ADC();
 98a:	0e 94 05 02 	call	0x40a	; 0x40a <ADC>
		break;
 98e:	08 95       	ret
		case 'E' | 'e': EEPROM();
 990:	0e 94 71 03 	call	0x6e2	; 0x6e2 <EEPROM>
		break;
 994:	08 95       	ret
		case 'U' | 'u': Params();   //Send USART parameter changes to another router   
 996:	0e 94 81 04 	call	0x902	; 0x902 <Params>
		break;
 99a:	08 95       	ret
		default:
		UART_Puts(MS5);
 99c:	8d e5       	ldi	r24, 0x5D	; 93
 99e:	95 e0       	ldi	r25, 0x05	; 5
 9a0:	0e 94 5f 01 	call	0x2be	; 0x2be <UART_Puts>
		HELP();
 9a4:	0e 94 8e 01 	call	0x31c	; 0x31c <HELP>
 9a8:	08 95       	ret

000009aa <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 9aa:	0e 94 a6 00 	call	0x14c	; 0x14c <Mega328P_Init>
	Banner();
 9ae:	0e 94 81 01 	call	0x302	; 0x302 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 9b2:	0e 94 ab 04 	call	0x956	; 0x956 <Command>
 9b6:	fd cf       	rjmp	.-6      	; 0x9b2 <main+0x8>

000009b8 <__subsf3>:
 9b8:	50 58       	subi	r21, 0x80	; 128

000009ba <__addsf3>:
 9ba:	bb 27       	eor	r27, r27
 9bc:	aa 27       	eor	r26, r26
 9be:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <__addsf3x>
 9c2:	0c 94 85 06 	jmp	0xd0a	; 0xd0a <__fp_round>
 9c6:	0e 94 77 06 	call	0xcee	; 0xcee <__fp_pscA>
 9ca:	38 f0       	brcs	.+14     	; 0x9da <__addsf3+0x20>
 9cc:	0e 94 7e 06 	call	0xcfc	; 0xcfc <__fp_pscB>
 9d0:	20 f0       	brcs	.+8      	; 0x9da <__addsf3+0x20>
 9d2:	39 f4       	brne	.+14     	; 0x9e2 <__addsf3+0x28>
 9d4:	9f 3f       	cpi	r25, 0xFF	; 255
 9d6:	19 f4       	brne	.+6      	; 0x9de <__addsf3+0x24>
 9d8:	26 f4       	brtc	.+8      	; 0x9e2 <__addsf3+0x28>
 9da:	0c 94 74 06 	jmp	0xce8	; 0xce8 <__fp_nan>
 9de:	0e f4       	brtc	.+2      	; 0x9e2 <__addsf3+0x28>
 9e0:	e0 95       	com	r30
 9e2:	e7 fb       	bst	r30, 7
 9e4:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>

000009e8 <__addsf3x>:
 9e8:	e9 2f       	mov	r30, r25
 9ea:	0e 94 96 06 	call	0xd2c	; 0xd2c <__fp_split3>
 9ee:	58 f3       	brcs	.-42     	; 0x9c6 <__addsf3+0xc>
 9f0:	ba 17       	cp	r27, r26
 9f2:	62 07       	cpc	r22, r18
 9f4:	73 07       	cpc	r23, r19
 9f6:	84 07       	cpc	r24, r20
 9f8:	95 07       	cpc	r25, r21
 9fa:	20 f0       	brcs	.+8      	; 0xa04 <__addsf3x+0x1c>
 9fc:	79 f4       	brne	.+30     	; 0xa1c <__addsf3x+0x34>
 9fe:	a6 f5       	brtc	.+104    	; 0xa68 <__addsf3x+0x80>
 a00:	0c 94 d0 06 	jmp	0xda0	; 0xda0 <__fp_zero>
 a04:	0e f4       	brtc	.+2      	; 0xa08 <__addsf3x+0x20>
 a06:	e0 95       	com	r30
 a08:	0b 2e       	mov	r0, r27
 a0a:	ba 2f       	mov	r27, r26
 a0c:	a0 2d       	mov	r26, r0
 a0e:	0b 01       	movw	r0, r22
 a10:	b9 01       	movw	r22, r18
 a12:	90 01       	movw	r18, r0
 a14:	0c 01       	movw	r0, r24
 a16:	ca 01       	movw	r24, r20
 a18:	a0 01       	movw	r20, r0
 a1a:	11 24       	eor	r1, r1
 a1c:	ff 27       	eor	r31, r31
 a1e:	59 1b       	sub	r21, r25
 a20:	99 f0       	breq	.+38     	; 0xa48 <__addsf3x+0x60>
 a22:	59 3f       	cpi	r21, 0xF9	; 249
 a24:	50 f4       	brcc	.+20     	; 0xa3a <__addsf3x+0x52>
 a26:	50 3e       	cpi	r21, 0xE0	; 224
 a28:	68 f1       	brcs	.+90     	; 0xa84 <__addsf3x+0x9c>
 a2a:	1a 16       	cp	r1, r26
 a2c:	f0 40       	sbci	r31, 0x00	; 0
 a2e:	a2 2f       	mov	r26, r18
 a30:	23 2f       	mov	r18, r19
 a32:	34 2f       	mov	r19, r20
 a34:	44 27       	eor	r20, r20
 a36:	58 5f       	subi	r21, 0xF8	; 248
 a38:	f3 cf       	rjmp	.-26     	; 0xa20 <__addsf3x+0x38>
 a3a:	46 95       	lsr	r20
 a3c:	37 95       	ror	r19
 a3e:	27 95       	ror	r18
 a40:	a7 95       	ror	r26
 a42:	f0 40       	sbci	r31, 0x00	; 0
 a44:	53 95       	inc	r21
 a46:	c9 f7       	brne	.-14     	; 0xa3a <__addsf3x+0x52>
 a48:	7e f4       	brtc	.+30     	; 0xa68 <__addsf3x+0x80>
 a4a:	1f 16       	cp	r1, r31
 a4c:	ba 0b       	sbc	r27, r26
 a4e:	62 0b       	sbc	r22, r18
 a50:	73 0b       	sbc	r23, r19
 a52:	84 0b       	sbc	r24, r20
 a54:	ba f0       	brmi	.+46     	; 0xa84 <__addsf3x+0x9c>
 a56:	91 50       	subi	r25, 0x01	; 1
 a58:	a1 f0       	breq	.+40     	; 0xa82 <__addsf3x+0x9a>
 a5a:	ff 0f       	add	r31, r31
 a5c:	bb 1f       	adc	r27, r27
 a5e:	66 1f       	adc	r22, r22
 a60:	77 1f       	adc	r23, r23
 a62:	88 1f       	adc	r24, r24
 a64:	c2 f7       	brpl	.-16     	; 0xa56 <__addsf3x+0x6e>
 a66:	0e c0       	rjmp	.+28     	; 0xa84 <__addsf3x+0x9c>
 a68:	ba 0f       	add	r27, r26
 a6a:	62 1f       	adc	r22, r18
 a6c:	73 1f       	adc	r23, r19
 a6e:	84 1f       	adc	r24, r20
 a70:	48 f4       	brcc	.+18     	; 0xa84 <__addsf3x+0x9c>
 a72:	87 95       	ror	r24
 a74:	77 95       	ror	r23
 a76:	67 95       	ror	r22
 a78:	b7 95       	ror	r27
 a7a:	f7 95       	ror	r31
 a7c:	9e 3f       	cpi	r25, 0xFE	; 254
 a7e:	08 f0       	brcs	.+2      	; 0xa82 <__addsf3x+0x9a>
 a80:	b0 cf       	rjmp	.-160    	; 0x9e2 <__addsf3+0x28>
 a82:	93 95       	inc	r25
 a84:	88 0f       	add	r24, r24
 a86:	08 f0       	brcs	.+2      	; 0xa8a <__addsf3x+0xa2>
 a88:	99 27       	eor	r25, r25
 a8a:	ee 0f       	add	r30, r30
 a8c:	97 95       	ror	r25
 a8e:	87 95       	ror	r24
 a90:	08 95       	ret

00000a92 <__divsf3>:
 a92:	0e 94 5d 05 	call	0xaba	; 0xaba <__divsf3x>
 a96:	0c 94 85 06 	jmp	0xd0a	; 0xd0a <__fp_round>
 a9a:	0e 94 7e 06 	call	0xcfc	; 0xcfc <__fp_pscB>
 a9e:	58 f0       	brcs	.+22     	; 0xab6 <__divsf3+0x24>
 aa0:	0e 94 77 06 	call	0xcee	; 0xcee <__fp_pscA>
 aa4:	40 f0       	brcs	.+16     	; 0xab6 <__divsf3+0x24>
 aa6:	29 f4       	brne	.+10     	; 0xab2 <__divsf3+0x20>
 aa8:	5f 3f       	cpi	r21, 0xFF	; 255
 aaa:	29 f0       	breq	.+10     	; 0xab6 <__divsf3+0x24>
 aac:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>
 ab0:	51 11       	cpse	r21, r1
 ab2:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>
 ab6:	0c 94 74 06 	jmp	0xce8	; 0xce8 <__fp_nan>

00000aba <__divsf3x>:
 aba:	0e 94 96 06 	call	0xd2c	; 0xd2c <__fp_split3>
 abe:	68 f3       	brcs	.-38     	; 0xa9a <__divsf3+0x8>

00000ac0 <__divsf3_pse>:
 ac0:	99 23       	and	r25, r25
 ac2:	b1 f3       	breq	.-20     	; 0xab0 <__divsf3+0x1e>
 ac4:	55 23       	and	r21, r21
 ac6:	91 f3       	breq	.-28     	; 0xaac <__divsf3+0x1a>
 ac8:	95 1b       	sub	r25, r21
 aca:	55 0b       	sbc	r21, r21
 acc:	bb 27       	eor	r27, r27
 ace:	aa 27       	eor	r26, r26
 ad0:	62 17       	cp	r22, r18
 ad2:	73 07       	cpc	r23, r19
 ad4:	84 07       	cpc	r24, r20
 ad6:	38 f0       	brcs	.+14     	; 0xae6 <__divsf3_pse+0x26>
 ad8:	9f 5f       	subi	r25, 0xFF	; 255
 ada:	5f 4f       	sbci	r21, 0xFF	; 255
 adc:	22 0f       	add	r18, r18
 ade:	33 1f       	adc	r19, r19
 ae0:	44 1f       	adc	r20, r20
 ae2:	aa 1f       	adc	r26, r26
 ae4:	a9 f3       	breq	.-22     	; 0xad0 <__divsf3_pse+0x10>
 ae6:	35 d0       	rcall	.+106    	; 0xb52 <__divsf3_pse+0x92>
 ae8:	0e 2e       	mov	r0, r30
 aea:	3a f0       	brmi	.+14     	; 0xafa <__divsf3_pse+0x3a>
 aec:	e0 e8       	ldi	r30, 0x80	; 128
 aee:	32 d0       	rcall	.+100    	; 0xb54 <__divsf3_pse+0x94>
 af0:	91 50       	subi	r25, 0x01	; 1
 af2:	50 40       	sbci	r21, 0x00	; 0
 af4:	e6 95       	lsr	r30
 af6:	00 1c       	adc	r0, r0
 af8:	ca f7       	brpl	.-14     	; 0xaec <__divsf3_pse+0x2c>
 afa:	2b d0       	rcall	.+86     	; 0xb52 <__divsf3_pse+0x92>
 afc:	fe 2f       	mov	r31, r30
 afe:	29 d0       	rcall	.+82     	; 0xb52 <__divsf3_pse+0x92>
 b00:	66 0f       	add	r22, r22
 b02:	77 1f       	adc	r23, r23
 b04:	88 1f       	adc	r24, r24
 b06:	bb 1f       	adc	r27, r27
 b08:	26 17       	cp	r18, r22
 b0a:	37 07       	cpc	r19, r23
 b0c:	48 07       	cpc	r20, r24
 b0e:	ab 07       	cpc	r26, r27
 b10:	b0 e8       	ldi	r27, 0x80	; 128
 b12:	09 f0       	breq	.+2      	; 0xb16 <__divsf3_pse+0x56>
 b14:	bb 0b       	sbc	r27, r27
 b16:	80 2d       	mov	r24, r0
 b18:	bf 01       	movw	r22, r30
 b1a:	ff 27       	eor	r31, r31
 b1c:	93 58       	subi	r25, 0x83	; 131
 b1e:	5f 4f       	sbci	r21, 0xFF	; 255
 b20:	3a f0       	brmi	.+14     	; 0xb30 <__divsf3_pse+0x70>
 b22:	9e 3f       	cpi	r25, 0xFE	; 254
 b24:	51 05       	cpc	r21, r1
 b26:	78 f0       	brcs	.+30     	; 0xb46 <__divsf3_pse+0x86>
 b28:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>
 b2c:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>
 b30:	5f 3f       	cpi	r21, 0xFF	; 255
 b32:	e4 f3       	brlt	.-8      	; 0xb2c <__divsf3_pse+0x6c>
 b34:	98 3e       	cpi	r25, 0xE8	; 232
 b36:	d4 f3       	brlt	.-12     	; 0xb2c <__divsf3_pse+0x6c>
 b38:	86 95       	lsr	r24
 b3a:	77 95       	ror	r23
 b3c:	67 95       	ror	r22
 b3e:	b7 95       	ror	r27
 b40:	f7 95       	ror	r31
 b42:	9f 5f       	subi	r25, 0xFF	; 255
 b44:	c9 f7       	brne	.-14     	; 0xb38 <__divsf3_pse+0x78>
 b46:	88 0f       	add	r24, r24
 b48:	91 1d       	adc	r25, r1
 b4a:	96 95       	lsr	r25
 b4c:	87 95       	ror	r24
 b4e:	97 f9       	bld	r25, 7
 b50:	08 95       	ret
 b52:	e1 e0       	ldi	r30, 0x01	; 1
 b54:	66 0f       	add	r22, r22
 b56:	77 1f       	adc	r23, r23
 b58:	88 1f       	adc	r24, r24
 b5a:	bb 1f       	adc	r27, r27
 b5c:	62 17       	cp	r22, r18
 b5e:	73 07       	cpc	r23, r19
 b60:	84 07       	cpc	r24, r20
 b62:	ba 07       	cpc	r27, r26
 b64:	20 f0       	brcs	.+8      	; 0xb6e <__divsf3_pse+0xae>
 b66:	62 1b       	sub	r22, r18
 b68:	73 0b       	sbc	r23, r19
 b6a:	84 0b       	sbc	r24, r20
 b6c:	ba 0b       	sbc	r27, r26
 b6e:	ee 1f       	adc	r30, r30
 b70:	88 f7       	brcc	.-30     	; 0xb54 <__divsf3_pse+0x94>
 b72:	e0 95       	com	r30
 b74:	08 95       	ret

00000b76 <__fixsfsi>:
 b76:	0e 94 c2 05 	call	0xb84	; 0xb84 <__fixunssfsi>
 b7a:	68 94       	set
 b7c:	b1 11       	cpse	r27, r1
 b7e:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>
 b82:	08 95       	ret

00000b84 <__fixunssfsi>:
 b84:	0e 94 9e 06 	call	0xd3c	; 0xd3c <__fp_splitA>
 b88:	88 f0       	brcs	.+34     	; 0xbac <__fixunssfsi+0x28>
 b8a:	9f 57       	subi	r25, 0x7F	; 127
 b8c:	98 f0       	brcs	.+38     	; 0xbb4 <__fixunssfsi+0x30>
 b8e:	b9 2f       	mov	r27, r25
 b90:	99 27       	eor	r25, r25
 b92:	b7 51       	subi	r27, 0x17	; 23
 b94:	b0 f0       	brcs	.+44     	; 0xbc2 <__fixunssfsi+0x3e>
 b96:	e1 f0       	breq	.+56     	; 0xbd0 <__fixunssfsi+0x4c>
 b98:	66 0f       	add	r22, r22
 b9a:	77 1f       	adc	r23, r23
 b9c:	88 1f       	adc	r24, r24
 b9e:	99 1f       	adc	r25, r25
 ba0:	1a f0       	brmi	.+6      	; 0xba8 <__fixunssfsi+0x24>
 ba2:	ba 95       	dec	r27
 ba4:	c9 f7       	brne	.-14     	; 0xb98 <__fixunssfsi+0x14>
 ba6:	14 c0       	rjmp	.+40     	; 0xbd0 <__fixunssfsi+0x4c>
 ba8:	b1 30       	cpi	r27, 0x01	; 1
 baa:	91 f0       	breq	.+36     	; 0xbd0 <__fixunssfsi+0x4c>
 bac:	0e 94 d0 06 	call	0xda0	; 0xda0 <__fp_zero>
 bb0:	b1 e0       	ldi	r27, 0x01	; 1
 bb2:	08 95       	ret
 bb4:	0c 94 d0 06 	jmp	0xda0	; 0xda0 <__fp_zero>
 bb8:	67 2f       	mov	r22, r23
 bba:	78 2f       	mov	r23, r24
 bbc:	88 27       	eor	r24, r24
 bbe:	b8 5f       	subi	r27, 0xF8	; 248
 bc0:	39 f0       	breq	.+14     	; 0xbd0 <__fixunssfsi+0x4c>
 bc2:	b9 3f       	cpi	r27, 0xF9	; 249
 bc4:	cc f3       	brlt	.-14     	; 0xbb8 <__fixunssfsi+0x34>
 bc6:	86 95       	lsr	r24
 bc8:	77 95       	ror	r23
 bca:	67 95       	ror	r22
 bcc:	b3 95       	inc	r27
 bce:	d9 f7       	brne	.-10     	; 0xbc6 <__fixunssfsi+0x42>
 bd0:	3e f4       	brtc	.+14     	; 0xbe0 <__fixunssfsi+0x5c>
 bd2:	90 95       	com	r25
 bd4:	80 95       	com	r24
 bd6:	70 95       	com	r23
 bd8:	61 95       	neg	r22
 bda:	7f 4f       	sbci	r23, 0xFF	; 255
 bdc:	8f 4f       	sbci	r24, 0xFF	; 255
 bde:	9f 4f       	sbci	r25, 0xFF	; 255
 be0:	08 95       	ret

00000be2 <__floatunsisf>:
 be2:	e8 94       	clt
 be4:	09 c0       	rjmp	.+18     	; 0xbf8 <__floatsisf+0x12>

00000be6 <__floatsisf>:
 be6:	97 fb       	bst	r25, 7
 be8:	3e f4       	brtc	.+14     	; 0xbf8 <__floatsisf+0x12>
 bea:	90 95       	com	r25
 bec:	80 95       	com	r24
 bee:	70 95       	com	r23
 bf0:	61 95       	neg	r22
 bf2:	7f 4f       	sbci	r23, 0xFF	; 255
 bf4:	8f 4f       	sbci	r24, 0xFF	; 255
 bf6:	9f 4f       	sbci	r25, 0xFF	; 255
 bf8:	99 23       	and	r25, r25
 bfa:	a9 f0       	breq	.+42     	; 0xc26 <__floatsisf+0x40>
 bfc:	f9 2f       	mov	r31, r25
 bfe:	96 e9       	ldi	r25, 0x96	; 150
 c00:	bb 27       	eor	r27, r27
 c02:	93 95       	inc	r25
 c04:	f6 95       	lsr	r31
 c06:	87 95       	ror	r24
 c08:	77 95       	ror	r23
 c0a:	67 95       	ror	r22
 c0c:	b7 95       	ror	r27
 c0e:	f1 11       	cpse	r31, r1
 c10:	f8 cf       	rjmp	.-16     	; 0xc02 <__floatsisf+0x1c>
 c12:	fa f4       	brpl	.+62     	; 0xc52 <__floatsisf+0x6c>
 c14:	bb 0f       	add	r27, r27
 c16:	11 f4       	brne	.+4      	; 0xc1c <__floatsisf+0x36>
 c18:	60 ff       	sbrs	r22, 0
 c1a:	1b c0       	rjmp	.+54     	; 0xc52 <__floatsisf+0x6c>
 c1c:	6f 5f       	subi	r22, 0xFF	; 255
 c1e:	7f 4f       	sbci	r23, 0xFF	; 255
 c20:	8f 4f       	sbci	r24, 0xFF	; 255
 c22:	9f 4f       	sbci	r25, 0xFF	; 255
 c24:	16 c0       	rjmp	.+44     	; 0xc52 <__floatsisf+0x6c>
 c26:	88 23       	and	r24, r24
 c28:	11 f0       	breq	.+4      	; 0xc2e <__floatsisf+0x48>
 c2a:	96 e9       	ldi	r25, 0x96	; 150
 c2c:	11 c0       	rjmp	.+34     	; 0xc50 <__floatsisf+0x6a>
 c2e:	77 23       	and	r23, r23
 c30:	21 f0       	breq	.+8      	; 0xc3a <__floatsisf+0x54>
 c32:	9e e8       	ldi	r25, 0x8E	; 142
 c34:	87 2f       	mov	r24, r23
 c36:	76 2f       	mov	r23, r22
 c38:	05 c0       	rjmp	.+10     	; 0xc44 <__floatsisf+0x5e>
 c3a:	66 23       	and	r22, r22
 c3c:	71 f0       	breq	.+28     	; 0xc5a <__floatsisf+0x74>
 c3e:	96 e8       	ldi	r25, 0x86	; 134
 c40:	86 2f       	mov	r24, r22
 c42:	70 e0       	ldi	r23, 0x00	; 0
 c44:	60 e0       	ldi	r22, 0x00	; 0
 c46:	2a f0       	brmi	.+10     	; 0xc52 <__floatsisf+0x6c>
 c48:	9a 95       	dec	r25
 c4a:	66 0f       	add	r22, r22
 c4c:	77 1f       	adc	r23, r23
 c4e:	88 1f       	adc	r24, r24
 c50:	da f7       	brpl	.-10     	; 0xc48 <__floatsisf+0x62>
 c52:	88 0f       	add	r24, r24
 c54:	96 95       	lsr	r25
 c56:	87 95       	ror	r24
 c58:	97 f9       	bld	r25, 7
 c5a:	08 95       	ret

00000c5c <floor>:
 c5c:	0e 94 b8 06 	call	0xd70	; 0xd70 <__fp_trunc>
 c60:	90 f0       	brcs	.+36     	; 0xc86 <floor+0x2a>
 c62:	9f 37       	cpi	r25, 0x7F	; 127
 c64:	48 f4       	brcc	.+18     	; 0xc78 <floor+0x1c>
 c66:	91 11       	cpse	r25, r1
 c68:	16 f0       	brts	.+4      	; 0xc6e <floor+0x12>
 c6a:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>
 c6e:	60 e0       	ldi	r22, 0x00	; 0
 c70:	70 e0       	ldi	r23, 0x00	; 0
 c72:	80 e8       	ldi	r24, 0x80	; 128
 c74:	9f eb       	ldi	r25, 0xBF	; 191
 c76:	08 95       	ret
 c78:	26 f4       	brtc	.+8      	; 0xc82 <floor+0x26>
 c7a:	1b 16       	cp	r1, r27
 c7c:	61 1d       	adc	r22, r1
 c7e:	71 1d       	adc	r23, r1
 c80:	81 1d       	adc	r24, r1
 c82:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <__fp_mintl>
 c86:	0c 94 66 06 	jmp	0xccc	; 0xccc <__fp_mpack>

00000c8a <__fp_inf>:
 c8a:	97 f9       	bld	r25, 7
 c8c:	9f 67       	ori	r25, 0x7F	; 127
 c8e:	80 e8       	ldi	r24, 0x80	; 128
 c90:	70 e0       	ldi	r23, 0x00	; 0
 c92:	60 e0       	ldi	r22, 0x00	; 0
 c94:	08 95       	ret

00000c96 <__fp_mintl>:
 c96:	88 23       	and	r24, r24
 c98:	71 f4       	brne	.+28     	; 0xcb6 <__fp_mintl+0x20>
 c9a:	77 23       	and	r23, r23
 c9c:	21 f0       	breq	.+8      	; 0xca6 <__fp_mintl+0x10>
 c9e:	98 50       	subi	r25, 0x08	; 8
 ca0:	87 2b       	or	r24, r23
 ca2:	76 2f       	mov	r23, r22
 ca4:	07 c0       	rjmp	.+14     	; 0xcb4 <__fp_mintl+0x1e>
 ca6:	66 23       	and	r22, r22
 ca8:	11 f4       	brne	.+4      	; 0xcae <__fp_mintl+0x18>
 caa:	99 27       	eor	r25, r25
 cac:	0d c0       	rjmp	.+26     	; 0xcc8 <__fp_mintl+0x32>
 cae:	90 51       	subi	r25, 0x10	; 16
 cb0:	86 2b       	or	r24, r22
 cb2:	70 e0       	ldi	r23, 0x00	; 0
 cb4:	60 e0       	ldi	r22, 0x00	; 0
 cb6:	2a f0       	brmi	.+10     	; 0xcc2 <__fp_mintl+0x2c>
 cb8:	9a 95       	dec	r25
 cba:	66 0f       	add	r22, r22
 cbc:	77 1f       	adc	r23, r23
 cbe:	88 1f       	adc	r24, r24
 cc0:	da f7       	brpl	.-10     	; 0xcb8 <__fp_mintl+0x22>
 cc2:	88 0f       	add	r24, r24
 cc4:	96 95       	lsr	r25
 cc6:	87 95       	ror	r24
 cc8:	97 f9       	bld	r25, 7
 cca:	08 95       	ret

00000ccc <__fp_mpack>:
 ccc:	9f 3f       	cpi	r25, 0xFF	; 255
 cce:	31 f0       	breq	.+12     	; 0xcdc <__fp_mpack_finite+0xc>

00000cd0 <__fp_mpack_finite>:
 cd0:	91 50       	subi	r25, 0x01	; 1
 cd2:	20 f4       	brcc	.+8      	; 0xcdc <__fp_mpack_finite+0xc>
 cd4:	87 95       	ror	r24
 cd6:	77 95       	ror	r23
 cd8:	67 95       	ror	r22
 cda:	b7 95       	ror	r27
 cdc:	88 0f       	add	r24, r24
 cde:	91 1d       	adc	r25, r1
 ce0:	96 95       	lsr	r25
 ce2:	87 95       	ror	r24
 ce4:	97 f9       	bld	r25, 7
 ce6:	08 95       	ret

00000ce8 <__fp_nan>:
 ce8:	9f ef       	ldi	r25, 0xFF	; 255
 cea:	80 ec       	ldi	r24, 0xC0	; 192
 cec:	08 95       	ret

00000cee <__fp_pscA>:
 cee:	00 24       	eor	r0, r0
 cf0:	0a 94       	dec	r0
 cf2:	16 16       	cp	r1, r22
 cf4:	17 06       	cpc	r1, r23
 cf6:	18 06       	cpc	r1, r24
 cf8:	09 06       	cpc	r0, r25
 cfa:	08 95       	ret

00000cfc <__fp_pscB>:
 cfc:	00 24       	eor	r0, r0
 cfe:	0a 94       	dec	r0
 d00:	12 16       	cp	r1, r18
 d02:	13 06       	cpc	r1, r19
 d04:	14 06       	cpc	r1, r20
 d06:	05 06       	cpc	r0, r21
 d08:	08 95       	ret

00000d0a <__fp_round>:
 d0a:	09 2e       	mov	r0, r25
 d0c:	03 94       	inc	r0
 d0e:	00 0c       	add	r0, r0
 d10:	11 f4       	brne	.+4      	; 0xd16 <__fp_round+0xc>
 d12:	88 23       	and	r24, r24
 d14:	52 f0       	brmi	.+20     	; 0xd2a <__fp_round+0x20>
 d16:	bb 0f       	add	r27, r27
 d18:	40 f4       	brcc	.+16     	; 0xd2a <__fp_round+0x20>
 d1a:	bf 2b       	or	r27, r31
 d1c:	11 f4       	brne	.+4      	; 0xd22 <__fp_round+0x18>
 d1e:	60 ff       	sbrs	r22, 0
 d20:	04 c0       	rjmp	.+8      	; 0xd2a <__fp_round+0x20>
 d22:	6f 5f       	subi	r22, 0xFF	; 255
 d24:	7f 4f       	sbci	r23, 0xFF	; 255
 d26:	8f 4f       	sbci	r24, 0xFF	; 255
 d28:	9f 4f       	sbci	r25, 0xFF	; 255
 d2a:	08 95       	ret

00000d2c <__fp_split3>:
 d2c:	57 fd       	sbrc	r21, 7
 d2e:	90 58       	subi	r25, 0x80	; 128
 d30:	44 0f       	add	r20, r20
 d32:	55 1f       	adc	r21, r21
 d34:	59 f0       	breq	.+22     	; 0xd4c <__fp_splitA+0x10>
 d36:	5f 3f       	cpi	r21, 0xFF	; 255
 d38:	71 f0       	breq	.+28     	; 0xd56 <__fp_splitA+0x1a>
 d3a:	47 95       	ror	r20

00000d3c <__fp_splitA>:
 d3c:	88 0f       	add	r24, r24
 d3e:	97 fb       	bst	r25, 7
 d40:	99 1f       	adc	r25, r25
 d42:	61 f0       	breq	.+24     	; 0xd5c <__fp_splitA+0x20>
 d44:	9f 3f       	cpi	r25, 0xFF	; 255
 d46:	79 f0       	breq	.+30     	; 0xd66 <__fp_splitA+0x2a>
 d48:	87 95       	ror	r24
 d4a:	08 95       	ret
 d4c:	12 16       	cp	r1, r18
 d4e:	13 06       	cpc	r1, r19
 d50:	14 06       	cpc	r1, r20
 d52:	55 1f       	adc	r21, r21
 d54:	f2 cf       	rjmp	.-28     	; 0xd3a <__fp_split3+0xe>
 d56:	46 95       	lsr	r20
 d58:	f1 df       	rcall	.-30     	; 0xd3c <__fp_splitA>
 d5a:	08 c0       	rjmp	.+16     	; 0xd6c <__fp_splitA+0x30>
 d5c:	16 16       	cp	r1, r22
 d5e:	17 06       	cpc	r1, r23
 d60:	18 06       	cpc	r1, r24
 d62:	99 1f       	adc	r25, r25
 d64:	f1 cf       	rjmp	.-30     	; 0xd48 <__fp_splitA+0xc>
 d66:	86 95       	lsr	r24
 d68:	71 05       	cpc	r23, r1
 d6a:	61 05       	cpc	r22, r1
 d6c:	08 94       	sec
 d6e:	08 95       	ret

00000d70 <__fp_trunc>:
 d70:	0e 94 9e 06 	call	0xd3c	; 0xd3c <__fp_splitA>
 d74:	a0 f0       	brcs	.+40     	; 0xd9e <__fp_trunc+0x2e>
 d76:	be e7       	ldi	r27, 0x7E	; 126
 d78:	b9 17       	cp	r27, r25
 d7a:	88 f4       	brcc	.+34     	; 0xd9e <__fp_trunc+0x2e>
 d7c:	bb 27       	eor	r27, r27
 d7e:	9f 38       	cpi	r25, 0x8F	; 143
 d80:	60 f4       	brcc	.+24     	; 0xd9a <__fp_trunc+0x2a>
 d82:	16 16       	cp	r1, r22
 d84:	b1 1d       	adc	r27, r1
 d86:	67 2f       	mov	r22, r23
 d88:	78 2f       	mov	r23, r24
 d8a:	88 27       	eor	r24, r24
 d8c:	98 5f       	subi	r25, 0xF8	; 248
 d8e:	f7 cf       	rjmp	.-18     	; 0xd7e <__fp_trunc+0xe>
 d90:	86 95       	lsr	r24
 d92:	77 95       	ror	r23
 d94:	67 95       	ror	r22
 d96:	b1 1d       	adc	r27, r1
 d98:	93 95       	inc	r25
 d9a:	96 39       	cpi	r25, 0x96	; 150
 d9c:	c8 f3       	brcs	.-14     	; 0xd90 <__fp_trunc+0x20>
 d9e:	08 95       	ret

00000da0 <__fp_zero>:
 da0:	e8 94       	clt

00000da2 <__fp_szero>:
 da2:	bb 27       	eor	r27, r27
 da4:	66 27       	eor	r22, r22
 da6:	77 27       	eor	r23, r23
 da8:	cb 01       	movw	r24, r22
 daa:	97 f9       	bld	r25, 7
 dac:	08 95       	ret
 dae:	16 f0       	brts	.+4      	; 0xdb4 <__fp_szero+0x12>
 db0:	0c 94 66 06 	jmp	0xccc	; 0xccc <__fp_mpack>
 db4:	0c 94 74 06 	jmp	0xce8	; 0xce8 <__fp_nan>
 db8:	68 94       	set
 dba:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>

00000dbe <log>:
 dbe:	0e 94 9e 06 	call	0xd3c	; 0xd3c <__fp_splitA>
 dc2:	a8 f3       	brcs	.-22     	; 0xdae <__fp_szero+0xc>
 dc4:	99 23       	and	r25, r25
 dc6:	c1 f3       	breq	.-16     	; 0xdb8 <__fp_szero+0x16>
 dc8:	ae f3       	brts	.-22     	; 0xdb4 <__fp_szero+0x12>
 dca:	df 93       	push	r29
 dcc:	cf 93       	push	r28
 dce:	1f 93       	push	r17
 dd0:	0f 93       	push	r16
 dd2:	ff 92       	push	r15
 dd4:	c9 2f       	mov	r28, r25
 dd6:	dd 27       	eor	r29, r29
 dd8:	88 23       	and	r24, r24
 dda:	2a f0       	brmi	.+10     	; 0xde6 <log+0x28>
 ddc:	21 97       	sbiw	r28, 0x01	; 1
 dde:	66 0f       	add	r22, r22
 de0:	77 1f       	adc	r23, r23
 de2:	88 1f       	adc	r24, r24
 de4:	da f7       	brpl	.-10     	; 0xddc <log+0x1e>
 de6:	20 e0       	ldi	r18, 0x00	; 0
 de8:	30 e0       	ldi	r19, 0x00	; 0
 dea:	40 e8       	ldi	r20, 0x80	; 128
 dec:	5f eb       	ldi	r21, 0xBF	; 191
 dee:	9f e3       	ldi	r25, 0x3F	; 63
 df0:	88 39       	cpi	r24, 0x98	; 152
 df2:	20 f0       	brcs	.+8      	; 0xdfc <log+0x3e>
 df4:	80 3e       	cpi	r24, 0xE0	; 224
 df6:	38 f0       	brcs	.+14     	; 0xe06 <log+0x48>
 df8:	21 96       	adiw	r28, 0x01	; 1
 dfa:	8f 77       	andi	r24, 0x7F	; 127
 dfc:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 e00:	e4 eb       	ldi	r30, 0xB4	; 180
 e02:	f0 e0       	ldi	r31, 0x00	; 0
 e04:	04 c0       	rjmp	.+8      	; 0xe0e <log+0x50>
 e06:	0e 94 dd 04 	call	0x9ba	; 0x9ba <__addsf3>
 e0a:	e1 ee       	ldi	r30, 0xE1	; 225
 e0c:	f0 e0       	ldi	r31, 0x00	; 0
 e0e:	0e 94 94 07 	call	0xf28	; 0xf28 <__fp_powser>
 e12:	8b 01       	movw	r16, r22
 e14:	be 01       	movw	r22, r28
 e16:	ec 01       	movw	r28, r24
 e18:	fb 2e       	mov	r15, r27
 e1a:	6f 57       	subi	r22, 0x7F	; 127
 e1c:	71 09       	sbc	r23, r1
 e1e:	75 95       	asr	r23
 e20:	77 1f       	adc	r23, r23
 e22:	88 0b       	sbc	r24, r24
 e24:	99 0b       	sbc	r25, r25
 e26:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <__floatsisf>
 e2a:	28 e1       	ldi	r18, 0x18	; 24
 e2c:	32 e7       	ldi	r19, 0x72	; 114
 e2e:	41 e3       	ldi	r20, 0x31	; 49
 e30:	5f e3       	ldi	r21, 0x3F	; 63
 e32:	0e 94 3a 07 	call	0xe74	; 0xe74 <__mulsf3x>
 e36:	af 2d       	mov	r26, r15
 e38:	98 01       	movw	r18, r16
 e3a:	ae 01       	movw	r20, r28
 e3c:	ff 90       	pop	r15
 e3e:	0f 91       	pop	r16
 e40:	1f 91       	pop	r17
 e42:	cf 91       	pop	r28
 e44:	df 91       	pop	r29
 e46:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <__addsf3x>
 e4a:	0c 94 85 06 	jmp	0xd0a	; 0xd0a <__fp_round>

00000e4e <__mulsf3>:
 e4e:	0e 94 3a 07 	call	0xe74	; 0xe74 <__mulsf3x>
 e52:	0c 94 85 06 	jmp	0xd0a	; 0xd0a <__fp_round>
 e56:	0e 94 77 06 	call	0xcee	; 0xcee <__fp_pscA>
 e5a:	38 f0       	brcs	.+14     	; 0xe6a <__mulsf3+0x1c>
 e5c:	0e 94 7e 06 	call	0xcfc	; 0xcfc <__fp_pscB>
 e60:	20 f0       	brcs	.+8      	; 0xe6a <__mulsf3+0x1c>
 e62:	95 23       	and	r25, r21
 e64:	11 f0       	breq	.+4      	; 0xe6a <__mulsf3+0x1c>
 e66:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>
 e6a:	0c 94 74 06 	jmp	0xce8	; 0xce8 <__fp_nan>
 e6e:	11 24       	eor	r1, r1
 e70:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>

00000e74 <__mulsf3x>:
 e74:	0e 94 96 06 	call	0xd2c	; 0xd2c <__fp_split3>
 e78:	70 f3       	brcs	.-36     	; 0xe56 <__mulsf3+0x8>

00000e7a <__mulsf3_pse>:
 e7a:	95 9f       	mul	r25, r21
 e7c:	c1 f3       	breq	.-16     	; 0xe6e <__mulsf3+0x20>
 e7e:	95 0f       	add	r25, r21
 e80:	50 e0       	ldi	r21, 0x00	; 0
 e82:	55 1f       	adc	r21, r21
 e84:	62 9f       	mul	r22, r18
 e86:	f0 01       	movw	r30, r0
 e88:	72 9f       	mul	r23, r18
 e8a:	bb 27       	eor	r27, r27
 e8c:	f0 0d       	add	r31, r0
 e8e:	b1 1d       	adc	r27, r1
 e90:	63 9f       	mul	r22, r19
 e92:	aa 27       	eor	r26, r26
 e94:	f0 0d       	add	r31, r0
 e96:	b1 1d       	adc	r27, r1
 e98:	aa 1f       	adc	r26, r26
 e9a:	64 9f       	mul	r22, r20
 e9c:	66 27       	eor	r22, r22
 e9e:	b0 0d       	add	r27, r0
 ea0:	a1 1d       	adc	r26, r1
 ea2:	66 1f       	adc	r22, r22
 ea4:	82 9f       	mul	r24, r18
 ea6:	22 27       	eor	r18, r18
 ea8:	b0 0d       	add	r27, r0
 eaa:	a1 1d       	adc	r26, r1
 eac:	62 1f       	adc	r22, r18
 eae:	73 9f       	mul	r23, r19
 eb0:	b0 0d       	add	r27, r0
 eb2:	a1 1d       	adc	r26, r1
 eb4:	62 1f       	adc	r22, r18
 eb6:	83 9f       	mul	r24, r19
 eb8:	a0 0d       	add	r26, r0
 eba:	61 1d       	adc	r22, r1
 ebc:	22 1f       	adc	r18, r18
 ebe:	74 9f       	mul	r23, r20
 ec0:	33 27       	eor	r19, r19
 ec2:	a0 0d       	add	r26, r0
 ec4:	61 1d       	adc	r22, r1
 ec6:	23 1f       	adc	r18, r19
 ec8:	84 9f       	mul	r24, r20
 eca:	60 0d       	add	r22, r0
 ecc:	21 1d       	adc	r18, r1
 ece:	82 2f       	mov	r24, r18
 ed0:	76 2f       	mov	r23, r22
 ed2:	6a 2f       	mov	r22, r26
 ed4:	11 24       	eor	r1, r1
 ed6:	9f 57       	subi	r25, 0x7F	; 127
 ed8:	50 40       	sbci	r21, 0x00	; 0
 eda:	9a f0       	brmi	.+38     	; 0xf02 <__mulsf3_pse+0x88>
 edc:	f1 f0       	breq	.+60     	; 0xf1a <__mulsf3_pse+0xa0>
 ede:	88 23       	and	r24, r24
 ee0:	4a f0       	brmi	.+18     	; 0xef4 <__mulsf3_pse+0x7a>
 ee2:	ee 0f       	add	r30, r30
 ee4:	ff 1f       	adc	r31, r31
 ee6:	bb 1f       	adc	r27, r27
 ee8:	66 1f       	adc	r22, r22
 eea:	77 1f       	adc	r23, r23
 eec:	88 1f       	adc	r24, r24
 eee:	91 50       	subi	r25, 0x01	; 1
 ef0:	50 40       	sbci	r21, 0x00	; 0
 ef2:	a9 f7       	brne	.-22     	; 0xede <__mulsf3_pse+0x64>
 ef4:	9e 3f       	cpi	r25, 0xFE	; 254
 ef6:	51 05       	cpc	r21, r1
 ef8:	80 f0       	brcs	.+32     	; 0xf1a <__mulsf3_pse+0xa0>
 efa:	0c 94 45 06 	jmp	0xc8a	; 0xc8a <__fp_inf>
 efe:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__fp_szero>
 f02:	5f 3f       	cpi	r21, 0xFF	; 255
 f04:	e4 f3       	brlt	.-8      	; 0xefe <__mulsf3_pse+0x84>
 f06:	98 3e       	cpi	r25, 0xE8	; 232
 f08:	d4 f3       	brlt	.-12     	; 0xefe <__mulsf3_pse+0x84>
 f0a:	86 95       	lsr	r24
 f0c:	77 95       	ror	r23
 f0e:	67 95       	ror	r22
 f10:	b7 95       	ror	r27
 f12:	f7 95       	ror	r31
 f14:	e7 95       	ror	r30
 f16:	9f 5f       	subi	r25, 0xFF	; 255
 f18:	c1 f7       	brne	.-16     	; 0xf0a <__mulsf3_pse+0x90>
 f1a:	fe 2b       	or	r31, r30
 f1c:	88 0f       	add	r24, r24
 f1e:	91 1d       	adc	r25, r1
 f20:	96 95       	lsr	r25
 f22:	87 95       	ror	r24
 f24:	97 f9       	bld	r25, 7
 f26:	08 95       	ret

00000f28 <__fp_powser>:
 f28:	df 93       	push	r29
 f2a:	cf 93       	push	r28
 f2c:	1f 93       	push	r17
 f2e:	0f 93       	push	r16
 f30:	ff 92       	push	r15
 f32:	ef 92       	push	r14
 f34:	df 92       	push	r13
 f36:	7b 01       	movw	r14, r22
 f38:	8c 01       	movw	r16, r24
 f3a:	68 94       	set
 f3c:	06 c0       	rjmp	.+12     	; 0xf4a <__fp_powser+0x22>
 f3e:	da 2e       	mov	r13, r26
 f40:	ef 01       	movw	r28, r30
 f42:	0e 94 3a 07 	call	0xe74	; 0xe74 <__mulsf3x>
 f46:	fe 01       	movw	r30, r28
 f48:	e8 94       	clt
 f4a:	a5 91       	lpm	r26, Z+
 f4c:	25 91       	lpm	r18, Z+
 f4e:	35 91       	lpm	r19, Z+
 f50:	45 91       	lpm	r20, Z+
 f52:	55 91       	lpm	r21, Z+
 f54:	a6 f3       	brts	.-24     	; 0xf3e <__fp_powser+0x16>
 f56:	ef 01       	movw	r28, r30
 f58:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <__addsf3x>
 f5c:	fe 01       	movw	r30, r28
 f5e:	97 01       	movw	r18, r14
 f60:	a8 01       	movw	r20, r16
 f62:	da 94       	dec	r13
 f64:	69 f7       	brne	.-38     	; 0xf40 <__fp_powser+0x18>
 f66:	df 90       	pop	r13
 f68:	ef 90       	pop	r14
 f6a:	ff 90       	pop	r15
 f6c:	0f 91       	pop	r16
 f6e:	1f 91       	pop	r17
 f70:	cf 91       	pop	r28
 f72:	df 91       	pop	r29
 f74:	08 95       	ret

00000f76 <__divmodhi4>:
 f76:	97 fb       	bst	r25, 7
 f78:	07 2e       	mov	r0, r23
 f7a:	16 f4       	brtc	.+4      	; 0xf80 <__divmodhi4+0xa>
 f7c:	00 94       	com	r0
 f7e:	07 d0       	rcall	.+14     	; 0xf8e <__divmodhi4_neg1>
 f80:	77 fd       	sbrc	r23, 7
 f82:	09 d0       	rcall	.+18     	; 0xf96 <__divmodhi4_neg2>
 f84:	0e 94 cf 07 	call	0xf9e	; 0xf9e <__udivmodhi4>
 f88:	07 fc       	sbrc	r0, 7
 f8a:	05 d0       	rcall	.+10     	; 0xf96 <__divmodhi4_neg2>
 f8c:	3e f4       	brtc	.+14     	; 0xf9c <__divmodhi4_exit>

00000f8e <__divmodhi4_neg1>:
 f8e:	90 95       	com	r25
 f90:	81 95       	neg	r24
 f92:	9f 4f       	sbci	r25, 0xFF	; 255
 f94:	08 95       	ret

00000f96 <__divmodhi4_neg2>:
 f96:	70 95       	com	r23
 f98:	61 95       	neg	r22
 f9a:	7f 4f       	sbci	r23, 0xFF	; 255

00000f9c <__divmodhi4_exit>:
 f9c:	08 95       	ret

00000f9e <__udivmodhi4>:
 f9e:	aa 1b       	sub	r26, r26
 fa0:	bb 1b       	sub	r27, r27
 fa2:	51 e1       	ldi	r21, 0x11	; 17
 fa4:	07 c0       	rjmp	.+14     	; 0xfb4 <__udivmodhi4_ep>

00000fa6 <__udivmodhi4_loop>:
 fa6:	aa 1f       	adc	r26, r26
 fa8:	bb 1f       	adc	r27, r27
 faa:	a6 17       	cp	r26, r22
 fac:	b7 07       	cpc	r27, r23
 fae:	10 f0       	brcs	.+4      	; 0xfb4 <__udivmodhi4_ep>
 fb0:	a6 1b       	sub	r26, r22
 fb2:	b7 0b       	sbc	r27, r23

00000fb4 <__udivmodhi4_ep>:
 fb4:	88 1f       	adc	r24, r24
 fb6:	99 1f       	adc	r25, r25
 fb8:	5a 95       	dec	r21
 fba:	a9 f7       	brne	.-22     	; 0xfa6 <__udivmodhi4_loop>
 fbc:	80 95       	com	r24
 fbe:	90 95       	com	r25
 fc0:	bc 01       	movw	r22, r24
 fc2:	cd 01       	movw	r24, r26
 fc4:	08 95       	ret

00000fc6 <strcmp>:
 fc6:	fb 01       	movw	r30, r22
 fc8:	dc 01       	movw	r26, r24
 fca:	8d 91       	ld	r24, X+
 fcc:	01 90       	ld	r0, Z+
 fce:	80 19       	sub	r24, r0
 fd0:	01 10       	cpse	r0, r1
 fd2:	d9 f3       	breq	.-10     	; 0xfca <strcmp+0x4>
 fd4:	99 0b       	sbc	r25, r25
 fd6:	08 95       	ret

00000fd8 <strcpy>:
 fd8:	fb 01       	movw	r30, r22
 fda:	dc 01       	movw	r26, r24
 fdc:	01 90       	ld	r0, Z+
 fde:	0d 92       	st	X+, r0
 fe0:	00 20       	and	r0, r0
 fe2:	e1 f7       	brne	.-8      	; 0xfdc <strcpy+0x4>
 fe4:	08 95       	ret

00000fe6 <_exit>:
 fe6:	f8 94       	cli

00000fe8 <__stop_program>:
 fe8:	ff cf       	rjmp	.-2      	; 0xfe8 <__stop_program>
