
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003b0  00800100  000006a8  0000073c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  008004b0  008004b0  00000aec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000b0  00000000  00000000  00000b60  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000013a2  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a1e  00000000  00000000  00001fb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000097f  00000000  00000000  000029d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000128  00000000  00000000  00003350  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000559  00000000  00000000  00003478  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000f7  00000000  00000000  000039d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  00003ac8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	14 e0       	ldi	r17, 0x04	; 4
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	e8 ea       	ldi	r30, 0xA8	; 168
  c8:	f6 e0       	ldi	r31, 0x06	; 6
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a0 3b       	cpi	r26, 0xB0	; 176
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	24 e0       	ldi	r18, 0x04	; 4
  d8:	a0 eb       	ldi	r26, 0xB0	; 176
  da:	b4 e0       	ldi	r27, 0x04	; 4
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	ad 3b       	cpi	r26, 0xBD	; 189
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 23 03 	call	0x646	; 0x646 <main>
  ea:	0c 94 52 03 	jmp	0x6a4	; 0x6a4 <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
		   .set	      temp,0			//Adress temporary value to 0

		   .section   ".text"			//Defines a text section of the program.
		   .global    Mega328P_Init
Mega328P_Init:
		   ldi    r16,0x07				//PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		   out    DDRB,r16				//Set pins PB0-PB2 as outputs
  f4:	04 b9       	out	0x04, r16	; 4
		   ldi    r16,0					//Clear r16
  f6:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//Clear the Port B data register
  f8:	05 b9       	out	0x05, r16	; 5
		   out    U2X0,r16				//initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		   ldi    r17,0x0				//clear r17
  fc:	10 e0       	ldi	r17, 0x00	; 0
		   ldi    r16,0x67				//set r16 to 0x67, 01100111
  fe:	07 e6       	ldi	r16, 0x67	; 103
		   sts	  UBRR0H,r17			//Clear buad rate high register
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		   sts	  UBRR0L,r16			//Set baud rate low register to 0x67
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
										//Together baud rate is set to 0x67
		   ldi	  r16,24				//load 0x18,00011000, into r16
 108:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ldi	  r16,6					//set r16 to 0x06, 00000110
 10e:	06 e0       	ldi	r16, 0x06	; 6
		   sts    UCSR0C,r16			//Set bit 1 and 2 of the USART Control and Status Register 0 C.
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
										//Exstablishes 8-bit character size for receiving/transmission
		   ldi    r16,0x87				//initialize ADC, 10000111
 114:	07 e8       	ldi	r16, 0x87	; 135
		   sts	  ADCSRA,r16			//Sets bit 0,1,2, and 7 of the ADC Control and Status Register A.
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
										//bits 2-0 set the division factor for the system clock and the input clock to 128
										//bit 7 enables ADC
		   ldi    r16,0x40				//set r16 to 0x40, 01000000
 11a:	00 e4       	ldi	r16, 0x40	; 64
		   sts    ADMUX,r16				//Sets bit 6 of the ADC multiplier selection register.
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
										//Sets the voltage reference of the ADC to Vcc with external capacitor with Aref pin
		   ldi    r16,0					//clear r16 
 120:	00 e0       	ldi	r16, 0x00	; 0
		   sts    ADCSRB,r16			//clear ADC Control and Status Register B
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		   ldi    r16,0xFE				//set r16 to 0xFE, 11111110
 126:	0e ef       	ldi	r16, 0xFE	; 254
		   sts    DIDR0,r16				//set bits 1-7 of the Digital Input Disable Register 0.
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
										//Effectively turns off digital input buffers from pins ADC7-ADC1. Prevents digital input
		   ldi    r16,0xFF				//set r16 to 0xFF, 11111111
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		   sts    DIDR1,r16				//set bits 0-1 of the Digital Input Disable Register 1.
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
										//Effectively turns off digital input on pins AIN1 and AIN0. 
										//This is a two bit register so there are only two bits that can be set
		   ret							//Return to main
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
		   call	  UART_Off				//stop receiving/transmitting
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 13a:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 13c:	00 91 b2 04 	lds	r16, 0x04B2	; 0x8004b2 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 140:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,4					//load 0x04 into r16 ***
 142:	04 e0       	ldi	r16, 0x04	; 4
		   out    PORTB,r16				//load 0x04 to Port B data register ***
 144:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop ***
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 14a:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 14c:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop. ***
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   call	  UART_On				//resume receiving/transmitting
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called
 156:	08 95       	ret

00000158 <LCD_Delay>:

LCD_Delay:
		   ldi    r16,0xFA				//set outer loop iterator
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:
D0:	       ldi    r17,0xFF				//set inner loop iterator
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	       dec    r17					//decrement inner iterator
 15c:	1a 95       	dec	r17
		   brne	  D1					//if D1 != 0 stay in loop
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
		   dec    r16					//decrement out loop
 160:	0a 95       	dec	r16
		   brne	  D0					//id D0 != 0 stay in loop
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
										//loop runs for 0xFA * 0xFF times.
										//just consumes clock cycles
		   ret							//return from where called
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 16a:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 16c:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 16e:	00 91 b2 04 	lds	r16, 0x04B2	; 0x8004b2 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 172:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,6					//load 0x06 into r16 ***
 174:	06 e0       	ldi	r16, 0x06	; 6
		   out    PORTB,r16				//load 0x06 into the Port B data register ***
 176:	05 b9       	out	0x05, r16	; 5
		   call   LCD_Delay				//Delay the LCD with double loop ***
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 17c:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 17e:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with double loop ***
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   call	  UART_On				//Resume receiving/transmitting
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0x00				//clear r16
 18e:	00 e0       	ldi	r16, 0x00	; 0
		   out    DDRD,r16				//Set PD0-PD7 to input pins
 190:	0a b9       	out	0x0a, r16	; 10
		   out    PORTB,4				//Set port B data register to 0x04 ***
 192:	45 b8       	out	0x05, r4	; 5
		   in     r16,PORTD				//store data in port D data register into r16
 194:	0b b1       	in	r16, 0x0b	; 11
		   sts    DATA,r16				//Store the data in r16 in global variable
 196:	00 93 b2 04 	sts	0x04B2, r16	; 0x8004b2 <DATA>
		   out    PORTB,0				//clear port B data register ***
 19a:	05 b8       	out	0x05, r0	; 5
		   call	  UART_On				//Resume receiving/transmitting
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called.
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On
UART_On:
		   ldi    r16,2					//set r16 to 2, 00000010
 1a2:	02 e0       	ldi	r16, 0x02	; 2
		   out    DDRD,r16				//Set PD2 as an output
 1a4:	0a b9       	out	0x0a, r16	; 10
		   ldi    r16,24				//load 0x18,00011000, into r16
 1a6:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ret							//return from where called.
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
		   ldi    r16,0					//Set r16 to 0
 1ae:	00 e0       	ldi	r16, 0x00	; 0
		   sts    UCSR0B,r16			//clear UCSR0B, effectively shuts down any receiving/transmitting
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		   ret							//return from where called.
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
		   lds    r16,UCSR0A			//set r16 to the UCSR0A
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r16,RXC0				//If bit 7 is high skip.
 1ba:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   ret							//If RXC0 is 0 than their is no data in the recieve buffer
 1bc:	08 95       	ret
										//No clear is needed. Return to where called
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   rjmp   UART_Clear			//Continue into loop until the recieve buffer is empty. 
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
		   lds    r16,UCSR0A			//Set r16 to UCSR0A
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs   r16,RXC0				//If bit 7 is high skip.
 1c8:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   rjmp	  UART_Get				//Remain in loop until there is data in the USART Receive Buffer
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   sts    ASCII,r16				//load character in the USART data register into ASCII
 1d0:	00 93 b4 04 	sts	0x04B4, r16	; 0x8004b4 <ASCII>
		   ret							//Return from where called
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
		   lds    r17,UCSR0A			//Set r16 to UCSR0A
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r17,UDRE0				//If bit 5 is high skip.
 1da:	15 ff       	sbrs	r17, 5
										//Skips if the transmit buffer is ready to receive new data
		   rjmp	  UART_Put				//Remain in loop until transmit buffer is ready
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
		   lds    r16,ASCII				//Load character in ASCII to r16
 1de:	00 91 b4 04 	lds	r16, 0x04B4	; 0x8004b4 <ASCII>
		   sts    UDR0,r16				//Store r16 into the USART data register
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   ret							//return from where called.
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		   ldi    r16,0xC7				//set r16 to 0xC7, 11000111
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		   sts    ADCSRA,r16			//Sets bits 7,6,2,1,0 of the ADCSRA
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ee <A2V1>:
										//Bits 7 and 6 enable and start the ADC conversion 
										//Bits 2-0 Set the division factor to 128
A2V1:	   lds    r16,ADCSRA			//Load ADCSRA to r16
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		   sbrc	  r16,ADSC				//if bit 6 is low skip
 1f2:	06 fd       	sbrc	r16, 6
										//Bit 6 or the ADSC is high so long as a conversion is being performed
		   rjmp   A2V1					//Stays in loop so long as conversion is being performed
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
										//Below stores the result in global variables
		   lds    r16,ADCL				//stores the ADC Register Low into r16
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		   sts    LADC,r16				//stores ADCL in LADC global variable
 1fa:	00 93 ba 04 	sts	0x04BA, r16	; 0x8004ba <LADC>
		   lds    r16,ADCH				//stores  the ADC Register High into r16
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		   sts    HADC,r16				//stores ADCH into HADC global variable
 202:	00 93 b3 04 	sts	0x04B3, r16	; 0x8004b3 <HADC>
		   ret							//return from where called
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		   sbic   EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Write			; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		   ldi    r18,0x00				; Set up address (r18:r17) in address register
 20c:	20 e0       	ldi	r18, 0x00	; 0
		   ldi    r17,0x05 
 20e:	15 e0       	ldi	r17, 0x05	; 5
		   ldi    r16,'F'				; Set up data in r16    
 210:	06 e4       	ldi	r16, 0x46	; 70
		   out    EEARH, r18      
 212:	22 bd       	out	0x22, r18	; 34
		   out    EEARL, r17			      
 214:	11 bd       	out	0x21, r17	; 33
		   out    EEDR,r16				; Write data (r16) to Data Register  
 216:	00 bd       	out	0x20, r16	; 32
		   sbi    EECR,EEMPE			; Write logical one to EEMPE
 218:	fa 9a       	sbi	0x1f, 2	; 31
		   sbi    EECR,EEPE				; Start eeprom write by setting EEPE
 21a:	f9 9a       	sbi	0x1f, 1	; 31
		   ret 
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		   sbic   EECR,EEPE    
 21e:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Read			; Wait for completion of previous write
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>
		   ldi    r18,0x00				; Set up address (r18:r17) in EEPROM address register
 222:	20 e0       	ldi	r18, 0x00	; 0
		   ldi    r17,0x05
 224:	15 e0       	ldi	r17, 0x05	; 5
		   ldi    r16,0x00   
 226:	00 e0       	ldi	r16, 0x00	; 0
		   out    EEARH,r18   
 228:	22 bd       	out	0x22, r18	; 34
		   out    EEARL,r17		   
 22a:	11 bd       	out	0x21, r17	; 33
		   sbi    EECR,EERE				; Start eeprom read by writing EERE
 22c:	f8 9a       	sbi	0x1f, 0	; 31
		   in     r16,EEDR				; Read data from Data Register
 22e:	00 b5       	in	r16, 0x20	; 32
		   sts    ASCII,r16  
 230:	00 93 b4 04 	sts	0x04B4, r16	; 0x8004b4 <ASCII>
		   ret
 234:	08 95       	ret

00000236 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	ec 01       	movw	r28, r24
	while (*str)                //While the current character is not the null character
 23c:	98 81       	ld	r25, Y
 23e:	99 23       	and	r25, r25
 240:	41 f0       	breq	.+16     	; 0x252 <UART_Puts+0x1c>
 242:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;         
 244:	90 93 b4 04 	sts	0x04B4, r25	; 0x8004b4 <ASCII>
		UART_Put();
 248:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)                //While the current character is not the null character
 24c:	99 91       	ld	r25, Y+
 24e:	91 11       	cpse	r25, r1
 250:	f9 cf       	rjmp	.-14     	; 0x244 <UART_Puts+0xe>
	{
		ASCII = *str++;         
		UART_Put();
	}
}
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 258:	cf 93       	push	r28
 25a:	df 93       	push	r29
 25c:	ec 01       	movw	r28, r24
	while (*str)
 25e:	98 81       	ld	r25, Y
 260:	99 23       	and	r25, r25
 262:	41 f0       	breq	.+16     	; 0x274 <LCD_Puts+0x1c>
 264:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 266:	90 93 b2 04 	sts	0x04B2, r25	; 0x8004b2 <DATA>
		LCD_Write_Data();
 26a:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 26e:	99 91       	ld	r25, Y+
 270:	91 11       	cpse	r25, r1
 272:	f9 cf       	rjmp	.-14     	; 0x266 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	08 95       	ret

0000027a <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 27a:	82 e9       	ldi	r24, 0x92	; 146
 27c:	94 e0       	ldi	r25, 0x04	; 4
 27e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS2);
 282:	8b e5       	ldi	r24, 0x5B	; 91
 284:	94 e0       	ldi	r25, 0x04	; 4
 286:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS4);
 28a:	8c e1       	ldi	r24, 0x1C	; 28
 28c:	94 e0       	ldi	r25, 0x04	; 4
 28e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 292:	08 95       	ret

00000294 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 294:	86 e2       	ldi	r24, 0x26	; 38
 296:	94 e0       	ldi	r25, 0x04	; 4
 298:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 29c:	08 95       	ret

0000029e <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Function Set
 29e:	84 e3       	ldi	r24, 0x34	; 52
 2a0:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <DATA>
	LCD_Write_Command();
 2a4:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Display Off
 2a8:	88 e0       	ldi	r24, 0x08	; 8
 2aa:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <DATA>
	LCD_Write_Command();
 2ae:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Return Home
 2b2:	82 e0       	ldi	r24, 0x02	; 2
 2b4:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <DATA>
	LCD_Write_Command();
 2b8:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Entry Mode Set - I
 2bc:	86 e0       	ldi	r24, 0x06	; 6
 2be:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <DATA>
	LCD_Write_Command();
 2c2:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Display On
 2c6:	8f e0       	ldi	r24, 0x0F	; 15
 2c8:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <DATA>
	LCD_Write_Command();
 2cc:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	LCD_Puts("Hello ECE412!");
 2d0:	80 e0       	ldi	r24, 0x00	; 0
 2d2:	91 e0       	ldi	r25, 0x01	; 1
 2d4:	0e 94 2c 01 	call	0x258	; 0x258 <LCD_Puts>
 2d8:	08 95       	ret

000002da <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 2da:	cf 93       	push	r28
 2dc:	df 93       	push	r29
	volts[0x1]='.';
 2de:	c5 eb       	ldi	r28, 0xB5	; 181
 2e0:	d4 e0       	ldi	r29, 0x04	; 4
 2e2:	8e e2       	ldi	r24, 0x2E	; 46
 2e4:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 2e6:	80 e2       	ldi	r24, 0x20	; 32
 2e8:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 2ea:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 2ec:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 2f0:	20 91 b3 04 	lds	r18, 0x04B3	; 0x8004b3 <HADC>
 2f4:	30 e0       	ldi	r19, 0x00	; 0
 2f6:	32 2f       	mov	r19, r18
 2f8:	22 27       	eor	r18, r18
 2fa:	80 91 ba 04 	lds	r24, 0x04BA	; 0x8004ba <LADC>
 2fe:	28 0f       	add	r18, r24
 300:	31 1d       	adc	r19, r1
 302:	c9 01       	movw	r24, r18
 304:	88 0f       	add	r24, r24
 306:	99 1f       	adc	r25, r25
 308:	22 0f       	add	r18, r18
 30a:	33 1f       	adc	r19, r19
 30c:	22 0f       	add	r18, r18
 30e:	33 1f       	adc	r19, r19
 310:	22 0f       	add	r18, r18
 312:	33 1f       	adc	r19, r19
 314:	82 0f       	add	r24, r18
 316:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 318:	ee ef       	ldi	r30, 0xFE	; 254
 31a:	f7 e0       	ldi	r31, 0x07	; 7
 31c:	bf 01       	movw	r22, r30
 31e:	0e 94 2a 03 	call	0x654	; 0x654 <__divmodhi4>
 322:	26 2f       	mov	r18, r22
 324:	30 e3       	ldi	r19, 0x30	; 48
 326:	36 0f       	add	r19, r22
 328:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 32a:	ac 01       	movw	r20, r24
 32c:	44 0f       	add	r20, r20
 32e:	55 1f       	adc	r21, r21
 330:	88 0f       	add	r24, r24
 332:	99 1f       	adc	r25, r25
 334:	88 0f       	add	r24, r24
 336:	99 1f       	adc	r25, r25
 338:	88 0f       	add	r24, r24
 33a:	99 1f       	adc	r25, r25
 33c:	84 0f       	add	r24, r20
 33e:	95 1f       	adc	r25, r21
 340:	bf 01       	movw	r22, r30
 342:	0e 94 2a 03 	call	0x654	; 0x654 <__divmodhi4>
 346:	30 e3       	ldi	r19, 0x30	; 48
 348:	36 0f       	add	r19, r22
 34a:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 34c:	90 93 bc 04 	sts	0x04BC, r25	; 0x8004bc <Acc+0x1>
 350:	80 93 bb 04 	sts	0x04BB, r24	; 0x8004bb <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 354:	8f 3f       	cpi	r24, 0xFF	; 255
 356:	93 40       	sbci	r25, 0x03	; 3
 358:	1c f0       	brlt	.+6      	; 0x360 <ADC+0x86>
 35a:	6f 5c       	subi	r22, 0xCF	; 207
 35c:	60 93 b7 04 	sts	0x04B7, r22	; 0x8004b7 <volts+0x2>
	if (volts[0x2] == 58)
 360:	80 91 b7 04 	lds	r24, 0x04B7	; 0x8004b7 <volts+0x2>
 364:	8a 33       	cpi	r24, 0x3A	; 58
 366:	31 f4       	brne	.+12     	; 0x374 <ADC+0x9a>
	{
		volts[0x2] = 48;
 368:	e5 eb       	ldi	r30, 0xB5	; 181
 36a:	f4 e0       	ldi	r31, 0x04	; 4
 36c:	80 e3       	ldi	r24, 0x30	; 48
 36e:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 370:	2f 5c       	subi	r18, 0xCF	; 207
 372:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 374:	85 eb       	ldi	r24, 0xB5	; 181
 376:	94 e0       	ldi	r25, 0x04	; 4
 378:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS6);
 37c:	86 ef       	ldi	r24, 0xF6	; 246
 37e:	93 e0       	ldi	r25, 0x03	; 3
 380:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 384:	df 91       	pop	r29
 386:	cf 91       	pop	r28
 388:	08 95       	ret

0000038a <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 38a:	8e e0       	ldi	r24, 0x0E	; 14
 38c:	91 e0       	ldi	r25, 0x01	; 1
 38e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 392:	8d e8       	ldi	r24, 0x8D	; 141
 394:	91 e0       	ldi	r25, 0x01	; 1
 396:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Write();
 39a:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\n");
 39e:	8d e8       	ldi	r24, 0x8D	; 141
 3a0:	91 e0       	ldi	r25, 0x01	; 1
 3a2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Read();
 3a6:	0e 94 0f 01 	call	0x21e	; 0x21e <EEPROM_Read>
	UART_Put();
 3aa:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\n");
 3ae:	8d e8       	ldi	r24, 0x8D	; 141
 3b0:	91 e0       	ldi	r25, 0x01	; 1
 3b2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 3b6:	08 95       	ret

000003b8 <setBaud>:
}

void setBaud(int i){         //Helper function that changes the baud rate
	UBRRValue = i;			 //Set UBBRBalue to preferred baud rate
 3b8:	80 93 b0 04 	sts	0x04B0, r24	; 0x8004b0 <__data_end>
 3bc:	90 93 b1 04 	sts	0x04B1, r25	; 0x8004b1 <__data_end+0x1>
	UBRR0L = (unsigned char) UBRRValue;		   //The rest of the baud rate goes here.
 3c0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UBRR0H = (unsigned char) (UBRRValue >> 8); //Upper four bits of the baud rate go here.
 3c4:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 3c8:	08 95       	ret

000003ca <baudRouter>:
	
	
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
 3ca:	87 e2       	ldi	r24, 0x27	; 39
 3cc:	91 e0       	ldi	r25, 0x01	; 1
 3ce:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';
 3d2:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 3d6:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 3da:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 3de:	88 23       	and	r24, r24
 3e0:	d1 f3       	breq	.-12     	; 0x3d6 <baudRouter+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 3e2:	83 33       	cpi	r24, 0x33	; 51
 3e4:	e9 f0       	breq	.+58     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 3e6:	28 f4       	brcc	.+10     	; 0x3f2 <baudRouter+0x28>
 3e8:	81 33       	cpi	r24, 0x31	; 49
 3ea:	41 f0       	breq	.+16     	; 0x3fc <baudRouter+0x32>
 3ec:	82 33       	cpi	r24, 0x32	; 50
 3ee:	79 f0       	breq	.+30     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 3f0:	32 c0       	rjmp	.+100    	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
 3f2:	84 33       	cpi	r24, 0x34	; 52
 3f4:	f1 f0       	breq	.+60     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
 3f6:	85 33       	cpi	r24, 0x35	; 53
 3f8:	29 f1       	breq	.+74     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
 3fa:	2d c0       	rjmp	.+90     	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
		
		case '1': setBaud(103);
 3fc:	87 e6       	ldi	r24, 0x67	; 103
 3fe:	90 e0       	ldi	r25, 0x00	; 0
 400:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <setBaud>
		UART_Puts("\r\nBaud rate = 9600.\r\n");
 404:	8a e7       	ldi	r24, 0x7A	; 122
 406:	91 e0       	ldi	r25, 0x01	; 1
 408:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 40c:	08 95       	ret
		case '2': setBaud(68);
 40e:	84 e4       	ldi	r24, 0x44	; 68
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <setBaud>
		UART_Puts("\r\nBaud rate = 14400\r\n");
 416:	80 e9       	ldi	r24, 0x90	; 144
 418:	91 e0       	ldi	r25, 0x01	; 1
 41a:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 41e:	08 95       	ret
		case '3': setBaud(51);
 420:	83 e3       	ldi	r24, 0x33	; 51
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <setBaud>
		UART_Puts("\r\nBaud rate = 19200\r\n");
 428:	86 ea       	ldi	r24, 0xA6	; 166
 42a:	91 e0       	ldi	r25, 0x01	; 1
 42c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 430:	08 95       	ret
		case '4': setBaud(34);
 432:	82 e2       	ldi	r24, 0x22	; 34
 434:	90 e0       	ldi	r25, 0x00	; 0
 436:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <setBaud>
		UART_Puts("\r\nBaud rate = 28800\r\n");
 43a:	8c eb       	ldi	r24, 0xBC	; 188
 43c:	91 e0       	ldi	r25, 0x01	; 1
 43e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 442:	08 95       	ret
		case '5': setBaud(25);
 444:	89 e1       	ldi	r24, 0x19	; 25
 446:	90 e0       	ldi	r25, 0x00	; 0
 448:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <setBaud>
		UART_Puts("\r\nBaud rate = 38400\r\n");
 44c:	82 ed       	ldi	r24, 0xD2	; 210
 44e:	91 e0       	ldi	r25, 0x01	; 1
 450:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 454:	08 95       	ret
		default:
		UART_Puts(MS5);
 456:	8d ef       	ldi	r24, 0xFD	; 253
 458:	93 e0       	ldi	r25, 0x03	; 3
 45a:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 45e:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 462:	08 95       	ret

00000464 <setDataBitNum>:
		break;
	}
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
 464:	88 ee       	ldi	r24, 0xE8	; 232
 466:	91 e0       	ldi	r25, 0x01	; 1
 468:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';
 46c:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 470:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 474:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 478:	88 23       	and	r24, r24
 47a:	d1 f3       	breq	.-12     	; 0x470 <setDataBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 47c:	87 33       	cpi	r24, 0x37	; 55
 47e:	a9 f0       	breq	.+42     	; 0x4aa <setDataBitNum+0x46>
 480:	28 f4       	brcc	.+10     	; 0x48c <setDataBitNum+0x28>
 482:	85 33       	cpi	r24, 0x35	; 53
 484:	41 f0       	breq	.+16     	; 0x496 <setDataBitNum+0x32>
 486:	86 33       	cpi	r24, 0x36	; 54
 488:	59 f0       	breq	.+22     	; 0x4a0 <setDataBitNum+0x3c>
 48a:	2d c0       	rjmp	.+90     	; 0x4e6 <setDataBitNum+0x82>
 48c:	88 33       	cpi	r24, 0x38	; 56
 48e:	91 f0       	breq	.+36     	; 0x4b4 <setDataBitNum+0x50>
 490:	89 33       	cpi	r24, 0x39	; 57
 492:	d1 f0       	breq	.+52     	; 0x4c8 <setDataBitNum+0x64>
 494:	28 c0       	rjmp	.+80     	; 0x4e6 <setDataBitNum+0x82>
		
		case '5':
		UCSR0C |= (0<<2)&&(0<<1); //if the bits 2-0 of UCSR0C == 000
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 5\r\n");
 496:	87 e2       	ldi	r24, 0x27	; 39
 498:	92 e0       	ldi	r25, 0x02	; 2
 49a:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 49e:	08 95       	ret
		case '6':
		UCSR0C |= (0<<2)&&(1<<1); //if bits 2-0 of UCSR0C == 001
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 6\r\n");
 4a0:	8e e3       	ldi	r24, 0x3E	; 62
 4a2:	92 e0       	ldi	r25, 0x02	; 2
 4a4:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 4a8:	08 95       	ret
		case '7':
		UCSR0C |= (1<<2)&&(0<<1); //if bits 2-0 of UCSr0C == 010
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 7\r\n");
 4aa:	85 e5       	ldi	r24, 0x55	; 85
 4ac:	92 e0       	ldi	r25, 0x02	; 2
 4ae:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 4b2:	08 95       	ret
		case '8':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 011
 4b4:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 4b8:	81 60       	ori	r24, 0x01	; 1
 4ba:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 8\r\n");
 4be:	8c e6       	ldi	r24, 0x6C	; 108
 4c0:	92 e0       	ldi	r25, 0x02	; 2
 4c2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 4c6:	08 95       	ret
		case '9':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 111
 4c8:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 4cc:	81 60       	ori	r24, 0x01	; 1
 4ce:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (1<<2);
 4d2:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 4d6:	84 60       	ori	r24, 0x04	; 4
 4d8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		UART_Puts("\r\n# of Data Bits = 9\r\n");
 4dc:	83 e8       	ldi	r24, 0x83	; 131
 4de:	92 e0       	ldi	r25, 0x02	; 2
 4e0:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 4e4:	08 95       	ret
		default:
		UART_Puts(MS5);
 4e6:	8d ef       	ldi	r24, 0xFD	; 253
 4e8:	93 e0       	ldi	r25, 0x03	; 3
 4ea:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 4ee:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 4f2:	08 95       	ret

000004f4 <setParity>:
		break;
	}
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
 4f4:	8a e9       	ldi	r24, 0x9A	; 154
 4f6:	92 e0       	ldi	r25, 0x02	; 2
 4f8:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';
 4fc:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 500:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 504:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 508:	88 23       	and	r24, r24
 50a:	d1 f3       	breq	.-12     	; 0x500 <setParity+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 50c:	8e 36       	cpi	r24, 0x6E	; 110
 50e:	29 f0       	breq	.+10     	; 0x51a <setParity+0x26>
 510:	8f 36       	cpi	r24, 0x6F	; 111
 512:	41 f0       	breq	.+16     	; 0x524 <setParity+0x30>
 514:	85 36       	cpi	r24, 0x65	; 101
 516:	a9 f4       	brne	.+42     	; 0x542 <setParity+0x4e>
 518:	0f c0       	rjmp	.+30     	; 0x538 <setParity+0x44>
		
		case 'N' | 'n':
		UCSR0C |= (0<<5)&&(0<<4);
		UART_Puts("\r\nParity = No Parity\r\n");
 51a:	8b ee       	ldi	r24, 0xEB	; 235
 51c:	92 e0       	ldi	r25, 0x02	; 2
 51e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 522:	08 95       	ret
		case 'O' | 'o':
		UCSR0C |= (1<<5)&&(1<<4);
 524:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 528:	81 60       	ori	r24, 0x01	; 1
 52a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\nParity = Odd Parity\r\n");
 52e:	82 e0       	ldi	r24, 0x02	; 2
 530:	93 e0       	ldi	r25, 0x03	; 3
 532:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 536:	08 95       	ret
		case 'E' | 'e':
		UCSR0C |= (1<<5)&&(0<<4);
		UART_Puts("\r\nParity = Even Parity\r\n");
 538:	8a e1       	ldi	r24, 0x1A	; 26
 53a:	93 e0       	ldi	r25, 0x03	; 3
 53c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 540:	08 95       	ret
		default:
		UART_Puts(MS5);
 542:	8d ef       	ldi	r24, 0xFD	; 253
 544:	93 e0       	ldi	r25, 0x03	; 3
 546:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 54a:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 54e:	08 95       	ret

00000550 <setStopBitNum>:
		break;
	}
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
 550:	83 e3       	ldi	r24, 0x33	; 51
 552:	93 e0       	ldi	r25, 0x03	; 3
 554:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';
 558:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 55c:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 560:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 564:	88 23       	and	r24, r24
 566:	d1 f3       	breq	.-12     	; 0x55c <setStopBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 568:	81 33       	cpi	r24, 0x31	; 49
 56a:	19 f0       	breq	.+6      	; 0x572 <setStopBitNum+0x22>
 56c:	82 33       	cpi	r24, 0x32	; 50
 56e:	31 f0       	breq	.+12     	; 0x57c <setStopBitNum+0x2c>
 570:	0f c0       	rjmp	.+30     	; 0x590 <setStopBitNum+0x40>
		
		case '1':
		UCSR0C |= (0<<3);
		UART_Puts("\r\n# of Stop Bits = 1\r\n");
 572:	8f e6       	ldi	r24, 0x6F	; 111
 574:	93 e0       	ldi	r25, 0x03	; 3
 576:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 57a:	08 95       	ret
		case '2':
		UCSR0C |= (1<<3);
 57c:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 580:	88 60       	ori	r24, 0x08	; 8
 582:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\n# of Stop Bits = 2\r\n");
 586:	86 e8       	ldi	r24, 0x86	; 134
 588:	93 e0       	ldi	r25, 0x03	; 3
 58a:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		break;
 58e:	08 95       	ret
		default:
		UART_Puts(MS5);
 590:	8d ef       	ldi	r24, 0xFD	; 253
 592:	93 e0       	ldi	r25, 0x03	; 3
 594:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 598:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 59c:	08 95       	ret

0000059e <Params>:
	}
}

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
 59e:	8d e9       	ldi	r24, 0x9D	; 157
 5a0:	93 e0       	ldi	r25, 0x03	; 3
 5a2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';
 5a6:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 5aa:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
	ASCII = '\0';
	while(ASCII == '\0'){
 5ae:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 5b2:	88 23       	and	r24, r24
 5b4:	d1 f3       	breq	.-12     	; 0x5aa <Params+0xc>
		
		UART_Get();
	}
	switch(ASCII){                  //For each parameter change send to another router which handles setting the parameter.
 5b6:	84 36       	cpi	r24, 0x64	; 100
 5b8:	61 f0       	breq	.+24     	; 0x5d2 <Params+0x34>
 5ba:	18 f4       	brcc	.+6      	; 0x5c2 <Params+0x24>
 5bc:	82 36       	cpi	r24, 0x62	; 98
 5be:	31 f0       	breq	.+12     	; 0x5cc <Params+0x2e>
 5c0:	11 c0       	rjmp	.+34     	; 0x5e4 <Params+0x46>
 5c2:	80 37       	cpi	r24, 0x70	; 112
 5c4:	49 f0       	breq	.+18     	; 0x5d8 <Params+0x3a>
 5c6:	83 37       	cpi	r24, 0x73	; 115
 5c8:	51 f0       	breq	.+20     	; 0x5de <Params+0x40>
 5ca:	0c c0       	rjmp	.+24     	; 0x5e4 <Params+0x46>
		
		case 'B' | 'b': baudRouter();
 5cc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <baudRouter>
		break;
 5d0:	08 95       	ret
		case 'D' | 'd': setDataBitNum();
 5d2:	0e 94 32 02 	call	0x464	; 0x464 <setDataBitNum>
		break;
 5d6:	08 95       	ret
		case 'P' | 'p': setParity();
 5d8:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <setParity>
		break;
 5dc:	08 95       	ret
		case 'S' | 's': setStopBitNum();
 5de:	0e 94 a8 02 	call	0x550	; 0x550 <setStopBitNum>
		break;
 5e2:	08 95       	ret
		default:
		UART_Puts(MS5);
 5e4:	8d ef       	ldi	r24, 0xFD	; 253
 5e6:	93 e0       	ldi	r25, 0x03	; 3
 5e8:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 5ec:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 5f0:	08 95       	ret

000005f2 <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 5f2:	86 e2       	ldi	r24, 0x26	; 38
 5f4:	94 e0       	ldi	r25, 0x04	; 4
 5f6:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';						
 5fa:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 5fe:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 602:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <ASCII>
 606:	88 23       	and	r24, r24
 608:	d1 f3       	breq	.-12     	; 0x5fe <Command+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 60a:	85 36       	cpi	r24, 0x65	; 101
 60c:	79 f0       	breq	.+30     	; 0x62c <Command+0x3a>
 60e:	18 f4       	brcc	.+6      	; 0x616 <Command+0x24>
 610:	81 36       	cpi	r24, 0x61	; 97
 612:	49 f0       	breq	.+18     	; 0x626 <Command+0x34>
 614:	11 c0       	rjmp	.+34     	; 0x638 <Command+0x46>
 616:	8c 36       	cpi	r24, 0x6C	; 108
 618:	19 f0       	breq	.+6      	; 0x620 <Command+0x2e>
 61a:	85 37       	cpi	r24, 0x75	; 117
 61c:	51 f0       	breq	.+20     	; 0x632 <Command+0x40>
 61e:	0c c0       	rjmp	.+24     	; 0x638 <Command+0x46>
	{
		case 'L' | 'l': LCD();
 620:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD>
		break;
 624:	08 95       	ret
		case 'A' | 'a': ADC();
 626:	0e 94 6d 01 	call	0x2da	; 0x2da <ADC>
		break;
 62a:	08 95       	ret
		case 'E' | 'e': EEPROM();
 62c:	0e 94 c5 01 	call	0x38a	; 0x38a <EEPROM>
		break;
 630:	08 95       	ret
		case 'U' | 'u': Params();   //Send USART parameter changes to another router   
 632:	0e 94 cf 02 	call	0x59e	; 0x59e <Params>
		break;
 636:	08 95       	ret
		default:
		UART_Puts(MS5);
 638:	8d ef       	ldi	r24, 0xFD	; 253
 63a:	93 e0       	ldi	r25, 0x03	; 3
 63c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 640:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 644:	08 95       	ret

00000646 <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 646:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 64a:	0e 94 3d 01 	call	0x27a	; 0x27a <Banner>
	while (1)
	{
		Command();				//infinite command loop
 64e:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <Command>
 652:	fd cf       	rjmp	.-6      	; 0x64e <main+0x8>

00000654 <__divmodhi4>:
 654:	97 fb       	bst	r25, 7
 656:	07 2e       	mov	r0, r23
 658:	16 f4       	brtc	.+4      	; 0x65e <__divmodhi4+0xa>
 65a:	00 94       	com	r0
 65c:	07 d0       	rcall	.+14     	; 0x66c <__divmodhi4_neg1>
 65e:	77 fd       	sbrc	r23, 7
 660:	09 d0       	rcall	.+18     	; 0x674 <__divmodhi4_neg2>
 662:	0e 94 3e 03 	call	0x67c	; 0x67c <__udivmodhi4>
 666:	07 fc       	sbrc	r0, 7
 668:	05 d0       	rcall	.+10     	; 0x674 <__divmodhi4_neg2>
 66a:	3e f4       	brtc	.+14     	; 0x67a <__divmodhi4_exit>

0000066c <__divmodhi4_neg1>:
 66c:	90 95       	com	r25
 66e:	81 95       	neg	r24
 670:	9f 4f       	sbci	r25, 0xFF	; 255
 672:	08 95       	ret

00000674 <__divmodhi4_neg2>:
 674:	70 95       	com	r23
 676:	61 95       	neg	r22
 678:	7f 4f       	sbci	r23, 0xFF	; 255

0000067a <__divmodhi4_exit>:
 67a:	08 95       	ret

0000067c <__udivmodhi4>:
 67c:	aa 1b       	sub	r26, r26
 67e:	bb 1b       	sub	r27, r27
 680:	51 e1       	ldi	r21, 0x11	; 17
 682:	07 c0       	rjmp	.+14     	; 0x692 <__udivmodhi4_ep>

00000684 <__udivmodhi4_loop>:
 684:	aa 1f       	adc	r26, r26
 686:	bb 1f       	adc	r27, r27
 688:	a6 17       	cp	r26, r22
 68a:	b7 07       	cpc	r27, r23
 68c:	10 f0       	brcs	.+4      	; 0x692 <__udivmodhi4_ep>
 68e:	a6 1b       	sub	r26, r22
 690:	b7 0b       	sbc	r27, r23

00000692 <__udivmodhi4_ep>:
 692:	88 1f       	adc	r24, r24
 694:	99 1f       	adc	r25, r25
 696:	5a 95       	dec	r21
 698:	a9 f7       	brne	.-22     	; 0x684 <__udivmodhi4_loop>
 69a:	80 95       	com	r24
 69c:	90 95       	com	r25
 69e:	bc 01       	movw	r22, r24
 6a0:	cd 01       	movw	r24, r26
 6a2:	08 95       	ret

000006a4 <_exit>:
 6a4:	f8 94       	cli

000006a6 <__stop_program>:
 6a6:	ff cf       	rjmp	.-2      	; 0x6a6 <__stop_program>
