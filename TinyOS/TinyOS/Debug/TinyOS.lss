
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000004fe  00800100  0000076a  000007fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000076a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  008005fe  008005fe  00000cfc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cfc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d2c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  00000d70  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000150a  00000000  00000000  00000e30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a36  00000000  00000000  0000233a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a67  00000000  00000000  00002d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000148  00000000  00000000  000037d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000599  00000000  00000000  00003920  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000f7  00000000  00000000  00003eb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00003fb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	15 e0       	ldi	r17, 0x05	; 5
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	ea e6       	ldi	r30, 0x6A	; 106
  c8:	f7 e0       	ldi	r31, 0x07	; 7
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	ae 3f       	cpi	r26, 0xFE	; 254
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	26 e0       	ldi	r18, 0x06	; 6
  d8:	ae ef       	ldi	r26, 0xFE	; 254
  da:	b5 e0       	ldi	r27, 0x05	; 5
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	ae 30       	cpi	r26, 0x0E	; 14
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 84 03 	call	0x708	; 0x708 <main>
  ea:	0c 94 b3 03 	jmp	0x766	; 0x766 <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
		   .set	      temp,0			//Adress temporary value to 0

		   .section   ".text"			//Defines a text section of the program.
		   .global    Mega328P_Init
Mega328P_Init:
		   ldi    r16,0x07				//PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		   out    DDRB,r16				//Set pins PB0-PB2 as outputs
  f4:	04 b9       	out	0x04, r16	; 4
		   ldi    r16,0					//Clear r16
  f6:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//Clear the Port B data register
  f8:	05 b9       	out	0x05, r16	; 5
		   out    U2X0,r16				//initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		   ldi    r17,0x0				//clear r17
  fc:	10 e0       	ldi	r17, 0x00	; 0
		   ldi    r16,0x67				//set r16 to 0x67, 01100111
  fe:	07 e6       	ldi	r16, 0x67	; 103
		   sts	  UBRR0H,r17			//Clear buad rate high register
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		   sts	  UBRR0L,r16			//Set baud rate low register to 0x67
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
										//Together baud rate is set to 0x67
		   ldi	  r16,24				//load 0x18,00011000, into r16
 108:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ldi	  r16,6					//set r16 to 0x06, 00000110
 10e:	06 e0       	ldi	r16, 0x06	; 6
		   sts    UCSR0C,r16			//Set bit 1 and 2 of the USART Control and Status Register 0 C.
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
										//Exstablishes 8-bit character size for receiving/transmission
		   ldi    r16,0x87				//initialize ADC, 10000111
 114:	07 e8       	ldi	r16, 0x87	; 135
		   sts	  ADCSRA,r16			//Sets bit 0,1,2, and 7 of the ADC Control and Status Register A.
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
										//bits 2-0 set the division factor for the system clock and the input clock to 128
										//bit 7 enables ADC
		   ldi    r16,0x40				//set r16 to 0x40, 01000000
 11a:	00 e4       	ldi	r16, 0x40	; 64
		   sts    ADMUX,r16				//Sets bit 6 of the ADC multiplier selection register.
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
										//Sets the voltage reference of the ADC to Vcc with external capacitor with Aref pin
		   ldi    r16,0					//clear r16 
 120:	00 e0       	ldi	r16, 0x00	; 0
		   sts    ADCSRB,r16			//clear ADC Control and Status Register B
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		   ldi    r16,0xFE				//set r16 to 0xFE, 11111110
 126:	0e ef       	ldi	r16, 0xFE	; 254
		   sts    DIDR0,r16				//set bits 1-7 of the Digital Input Disable Register 0.
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
										//Effectively turns off digital input buffers from pins ADC7-ADC1. Prevents digital input
		   ldi    r16,0xFF				//set r16 to 0xFF, 11111111
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		   sts    DIDR1,r16				//set bits 0-1 of the Digital Input Disable Register 1.
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
										//Effectively turns off digital input on pins AIN1 and AIN0. 
										//This is a two bit register so there are only two bits that can be set
		   ret							//Return to main
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
		   call	  UART_Off				//stop receiving/transmitting
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 13a:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 13c:	00 91 01 06 	lds	r16, 0x0601	; 0x800601 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 140:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,4					//load 0x04 into r16 ***
 142:	04 e0       	ldi	r16, 0x04	; 4
		   out    PORTB,r16				//load 0x04 to Port B data register ***
 144:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop ***
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 14a:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 14c:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with a double loop. ***
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   call	  UART_On				//resume receiving/transmitting
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called
 156:	08 95       	ret

00000158 <LCD_Delay>:

LCD_Delay:
		   ldi    r16,0xFA				//set outer loop iterator
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:
D0:	       ldi    r17,0xFF				//set inner loop iterator
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	       dec    r17					//decrement inner iterator
 15c:	1a 95       	dec	r17
		   brne	  D1					//if D1 != 0 stay in loop
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
		   dec    r16					//decrement out loop
 160:	0a 95       	dec	r16
		   brne	  D0					//id D0 != 0 stay in loop
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
										//loop runs for 0xFA * 0xFF times.
										//just consumes clock cycles
		   ret							//return from where called
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0xFF				//PD0 - PD7 as outputs
 16a:	0f ef       	ldi	r16, 0xFF	; 255
		   out    DDRD,r16				//Set PD0-PD7 as outputs
 16c:	0a b9       	out	0x0a, r16	; 10
		   lds    r16,DATA				//load Data to be sent from global variable
 16e:	00 91 01 06 	lds	r16, 0x0601	; 0x800601 <DATA>
		   out    PORTD,r16				//load data to Port D data register
 172:	0b b9       	out	0x0b, r16	; 11
		   ldi    r16,6					//load 0x06 into r16 ***
 174:	06 e0       	ldi	r16, 0x06	; 6
		   out    PORTB,r16				//load 0x06 into the Port B data register ***
 176:	05 b9       	out	0x05, r16	; 5
		   call   LCD_Delay				//Delay the LCD with double loop ***
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   ldi    r16,0					//clear r16 ***
 17c:	00 e0       	ldi	r16, 0x00	; 0
		   out    PORTB,r16				//clear port B data register ***
 17e:	05 b9       	out	0x05, r16	; 5
		   call	  LCD_Delay				//Delay the LCD with double loop ***
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
		   call	  UART_On				//Resume receiving/transmitting
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
		   call	  UART_Off				//Stop receiving/transmitting
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
		   ldi    r16,0x00				//clear r16
 18e:	00 e0       	ldi	r16, 0x00	; 0
		   out    DDRD,r16				//Set PD0-PD7 to input pins
 190:	0a b9       	out	0x0a, r16	; 10
		   out    PORTB,4				//Set port B data register to 0x04 ***
 192:	45 b8       	out	0x05, r4	; 5
		   in     r16,PORTD				//store data in port D data register into r16
 194:	0b b1       	in	r16, 0x0b	; 11
		   sts    DATA,r16				//Store the data in r16 in global variable
 196:	00 93 01 06 	sts	0x0601, r16	; 0x800601 <DATA>
		   out    PORTB,0				//clear port B data register ***
 19a:	05 b8       	out	0x05, r0	; 5
		   call	  UART_On				//Resume receiving/transmitting
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
		   ret							//return from where called.
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On
UART_On:
		   ldi    r16,2					//set r16 to 2, 00000010
 1a2:	02 e0       	ldi	r16, 0x02	; 2
		   out    DDRD,r16				//Set PD2 as an output
 1a4:	0a b9       	out	0x0a, r16	; 10
		   ldi    r16,24				//load 0x18,00011000, into r16
 1a6:	08 e1       	ldi	r16, 0x18	; 24
		   sts	  UCSR0B,r16			//Set bit 3 and 4 of the USART Control and Status Register 0 B. 
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
										//Allows for Receiving and Transmitting
		   ret							//return from where called.
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
		   ldi    r16,0					//Set r16 to 0
 1ae:	00 e0       	ldi	r16, 0x00	; 0
		   sts    UCSR0B,r16			//clear UCSR0B, effectively shuts down any receiving/transmitting
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		   ret							//return from where called.
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
		   lds    r16,UCSR0A			//set r16 to the UCSR0A
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r16,RXC0				//If bit 7 is high skip.
 1ba:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   ret							//If RXC0 is 0 than their is no data in the recieve buffer
 1bc:	08 95       	ret
										//No clear is needed. Return to where called
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   rjmp   UART_Clear			//Continue into loop until the recieve buffer is empty. 
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
		   lds    r16,UCSR0A			//Set r16 to UCSR0A
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs   r16,RXC0				//If bit 7 is high skip.
 1c8:	07 ff       	sbrs	r16, 7
										//Skips if there is data in the USART Receive Buffer
		   rjmp	  UART_Get				//Remain in loop until there is data in the USART Receive Buffer
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
		   lds    r16,UDR0				//Set r16 to the USART data register. ***
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   sts    ASCII,r16				//load character in the USART data register into ASCII
 1d0:	00 93 03 06 	sts	0x0603, r16	; 0x800603 <ASCII>
		   ret							//Return from where called
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
		   lds    r17,UCSR0A			//Set r16 to UCSR0A
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		   sbrs	  r17,UDRE0				//If bit 5 is high skip.
 1da:	15 ff       	sbrs	r17, 5
										//Skips if the transmit buffer is ready to receive new data
		   rjmp	  UART_Put				//Remain in loop until transmit buffer is ready
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
		   lds    r16,ASCII				//Load character in ASCII to r16
 1de:	00 91 03 06 	lds	r16, 0x0603	; 0x800603 <ASCII>
		   sts    UDR0,r16				//Store r16 into the USART data register
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		   ret							//return from where called.
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		   ldi    r16,0xC7				//set r16 to 0xC7, 11000111
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		   sts    ADCSRA,r16			//Sets bits 7,6,2,1,0 of the ADCSRA
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ee <A2V1>:
										//Bits 7 and 6 enable and start the ADC conversion 
										//Bits 2-0 Set the division factor to 128
A2V1:	   lds    r16,ADCSRA			//Load ADCSRA to r16
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		   sbrc	  r16,ADSC				//if bit 6 is low skip
 1f2:	06 fd       	sbrc	r16, 6
										//Bit 6 or the ADSC is high so long as a conversion is being performed
		   rjmp   A2V1					//Stays in loop so long as conversion is being performed
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
										//Below stores the result in global variables
		   lds    r16,ADCL				//stores the ADC Register Low into r16
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		   sts    LADC,r16				//stores ADCL in LADC global variable
 1fa:	00 93 0a 06 	sts	0x060A, r16	; 0x80060a <LADC>
		   lds    r16,ADCH				//stores  the ADC Register High into r16
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		   sts    HADC,r16				//stores ADCH into HADC global variable
 202:	00 93 02 06 	sts	0x0602, r16	; 0x800602 <HADC>
		   ret							//return from where called
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		   sbic   EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Write			; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		   lds    r18,EEPROMH			; Set up address (r18:r17) in address register
 20c:	20 91 04 06 	lds	r18, 0x0604	; 0x800604 <EEPROMH>
		   lds    r17,EEPROML 
 210:	10 91 0b 06 	lds	r17, 0x060B	; 0x80060b <EEPROML>
		   lds    r16,EEPROMV			; Set up data in r16    
 214:	00 91 00 06 	lds	r16, 0x0600	; 0x800600 <EEPROMV>
		   out    EEARH, r18      
 218:	22 bd       	out	0x22, r18	; 34
		   out    EEARL, r17			      
 21a:	11 bd       	out	0x21, r17	; 33
		   out    EEDR,r16				; Write data (r16) to Data Register  
 21c:	00 bd       	out	0x20, r16	; 32
		   sbi    EECR,EEMPE			; Write logical one to EEMPE
 21e:	fa 9a       	sbi	0x1f, 2	; 31
		   sbi    EECR,EEPE				; Start eeprom write by setting EEPE
 220:	f9 9a       	sbi	0x1f, 1	; 31
		   ret 
 222:	08 95       	ret

00000224 <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		   sbic   EECR,EEPE    
 224:	f9 99       	sbic	0x1f, 1	; 31
		   rjmp   EEPROM_Read			; Wait for completion of previous write
 226:	fe cf       	rjmp	.-4      	; 0x224 <EEPROM_Read>
		   lds    r18,EEPROMH			; Set up address (r18:r17) in EEPROM address register
 228:	20 91 04 06 	lds	r18, 0x0604	; 0x800604 <EEPROMH>
		   lds    r17,EEPROML
 22c:	10 91 0b 06 	lds	r17, 0x060B	; 0x80060b <EEPROML>
		   ldi    r16,0x00   
 230:	00 e0       	ldi	r16, 0x00	; 0
		   out    EEARH,r18   
 232:	22 bd       	out	0x22, r18	; 34
		   out    EEARL,r17		   
 234:	11 bd       	out	0x21, r17	; 33
		   sbi    EECR,EERE				; Start eeprom read by writing EERE
 236:	f8 9a       	sbi	0x1f, 0	; 31
		   in     r16,EEDR				; Read data from Data Register
 238:	00 b5       	in	r16, 0x20	; 32
		   sts    ASCII,r16  
 23a:	00 93 03 06 	sts	0x0603, r16	; 0x800603 <ASCII>
		   ret
 23e:	08 95       	ret

00000240 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 240:	cf 93       	push	r28
 242:	df 93       	push	r29
 244:	ec 01       	movw	r28, r24
	while (*str)                //While the current character is not the null character
 246:	98 81       	ld	r25, Y
 248:	99 23       	and	r25, r25
 24a:	41 f0       	breq	.+16     	; 0x25c <UART_Puts+0x1c>
 24c:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;         
 24e:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <ASCII>
		UART_Put();
 252:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)                //While the current character is not the null character
 256:	99 91       	ld	r25, Y+
 258:	91 11       	cpse	r25, r1
 25a:	f9 cf       	rjmp	.-14     	; 0x24e <UART_Puts+0xe>
	{
		ASCII = *str++;         
		UART_Put();
	}
}
 25c:	df 91       	pop	r29
 25e:	cf 91       	pop	r28
 260:	08 95       	ret

00000262 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 262:	cf 93       	push	r28
 264:	df 93       	push	r29
 266:	ec 01       	movw	r28, r24
	while (*str)
 268:	98 81       	ld	r25, Y
 26a:	99 23       	and	r25, r25
 26c:	41 f0       	breq	.+16     	; 0x27e <LCD_Puts+0x1c>
 26e:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 270:	90 93 01 06 	sts	0x0601, r25	; 0x800601 <DATA>
		LCD_Write_Data();
 274:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 278:	99 91       	ld	r25, Y+
 27a:	91 11       	cpse	r25, r1
 27c:	f9 cf       	rjmp	.-14     	; 0x270 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 27e:	df 91       	pop	r29
 280:	cf 91       	pop	r28
 282:	08 95       	ret

00000284 <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 284:	81 ee       	ldi	r24, 0xE1	; 225
 286:	95 e0       	ldi	r25, 0x05	; 5
 288:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	UART_Puts(MS2);
 28c:	8a ea       	ldi	r24, 0xAA	; 170
 28e:	95 e0       	ldi	r25, 0x05	; 5
 290:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	UART_Puts(MS4);
 294:	8b e6       	ldi	r24, 0x6B	; 107
 296:	95 e0       	ldi	r25, 0x05	; 5
 298:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
 29c:	08 95       	ret

0000029e <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 29e:	85 e7       	ldi	r24, 0x75	; 117
 2a0:	95 e0       	ldi	r25, 0x05	; 5
 2a2:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
 2a6:	08 95       	ret

000002a8 <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Function Set
 2a8:	84 e3       	ldi	r24, 0x34	; 52
 2aa:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <DATA>
	LCD_Write_Command();
 2ae:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Display Off
 2b2:	88 e0       	ldi	r24, 0x08	; 8
 2b4:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <DATA>
	LCD_Write_Command();
 2b8:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Return Home
 2bc:	82 e0       	ldi	r24, 0x02	; 2
 2be:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <DATA>
	LCD_Write_Command();
 2c2:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Entry Mode Set - I
 2c6:	86 e0       	ldi	r24, 0x06	; 6
 2c8:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <DATA>
	LCD_Write_Command();
 2cc:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Display On
 2d0:	8f e0       	ldi	r24, 0x0F	; 15
 2d2:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <DATA>
	LCD_Write_Command();
 2d6:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	LCD_Puts("Hello ECE412!");
 2da:	80 e0       	ldi	r24, 0x00	; 0
 2dc:	91 e0       	ldi	r25, 0x01	; 1
 2de:	0e 94 31 01 	call	0x262	; 0x262 <LCD_Puts>
 2e2:	08 95       	ret

000002e4 <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
	volts[0x1]='.';  
 2e8:	c5 e0       	ldi	r28, 0x05	; 5
 2ea:	d6 e0       	ldi	r29, 0x06	; 6
 2ec:	8e e2       	ldi	r24, 0x2E	; 46
 2ee:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';  
 2f0:	80 e2       	ldi	r24, 0x20	; 32
 2f2:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;  
 2f4:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();  
 2f6:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + ((int)LADC))*0xA; 
 2fa:	20 91 02 06 	lds	r18, 0x0602	; 0x800602 <HADC>
 2fe:	30 e0       	ldi	r19, 0x00	; 0
 300:	32 2f       	mov	r19, r18
 302:	22 27       	eor	r18, r18
 304:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <LADC>
 308:	28 0f       	add	r18, r24
 30a:	31 1d       	adc	r19, r1
 30c:	c9 01       	movw	r24, r18
 30e:	88 0f       	add	r24, r24
 310:	99 1f       	adc	r25, r25
 312:	22 0f       	add	r18, r18
 314:	33 1f       	adc	r19, r19
 316:	22 0f       	add	r18, r18
 318:	33 1f       	adc	r19, r19
 31a:	22 0f       	add	r18, r18
 31c:	33 1f       	adc	r19, r19
 31e:	82 0f       	add	r24, r18
 320:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);  
 322:	ee ef       	ldi	r30, 0xFE	; 254
 324:	f7 e0       	ldi	r31, 0x07	; 7
 326:	bf 01       	movw	r22, r30
 328:	0e 94 8b 03 	call	0x716	; 0x716 <__divmodhi4>
 32c:	26 2f       	mov	r18, r22
 32e:	30 e3       	ldi	r19, 0x30	; 48
 330:	36 0f       	add	r19, r22
 332:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;  
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;  
 334:	ac 01       	movw	r20, r24
 336:	44 0f       	add	r20, r20
 338:	55 1f       	adc	r21, r21
 33a:	88 0f       	add	r24, r24
 33c:	99 1f       	adc	r25, r25
 33e:	88 0f       	add	r24, r24
 340:	99 1f       	adc	r25, r25
 342:	88 0f       	add	r24, r24
 344:	99 1f       	adc	r25, r25
 346:	84 0f       	add	r24, r20
 348:	95 1f       	adc	r25, r21
 34a:	bf 01       	movw	r22, r30
 34c:	0e 94 8b 03 	call	0x716	; 0x716 <__divmodhi4>
 350:	30 e3       	ldi	r19, 0x30	; 48
 352:	36 0f       	add	r19, r22
 354:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;  
 356:	90 93 0d 06 	sts	0x060D, r25	; 0x80060d <Acc+0x1>
 35a:	80 93 0c 06 	sts	0x060C, r24	; 0x80060c <Acc>
	if (Acc >= 0x3FF) 
 35e:	8f 3f       	cpi	r24, 0xFF	; 255
 360:	93 40       	sbci	r25, 0x03	; 3
 362:	1c f0       	brlt	.+6      	; 0x36a <ADC+0x86>
		volts[0x2]++;  
 364:	6f 5c       	subi	r22, 0xCF	; 207
 366:	60 93 07 06 	sts	0x0607, r22	; 0x800607 <volts+0x2>
	if (volts[0x2] == 58){
 36a:	80 91 07 06 	lds	r24, 0x0607	; 0x800607 <volts+0x2>
 36e:	8a 33       	cpi	r24, 0x3A	; 58
 370:	31 f4       	brne	.+12     	; 0x37e <ADC+0x9a>
		volts[0x2] = 48;  
 372:	e5 e0       	ldi	r30, 0x05	; 5
 374:	f6 e0       	ldi	r31, 0x06	; 6
 376:	80 e3       	ldi	r24, 0x30	; 48
 378:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;  
 37a:	2f 5c       	subi	r18, 0xCF	; 207
 37c:	20 83       	st	Z, r18
	}  
	UART_Puts(volts);  
 37e:	85 e0       	ldi	r24, 0x05	; 5
 380:	96 e0       	ldi	r25, 0x06	; 6
 382:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	UART_Puts(MS6);
 386:	85 e4       	ldi	r24, 0x45	; 69
 388:	95 e0       	ldi	r25, 0x05	; 5
 38a:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	
	/* Re-engineer this subroutine to display temperature in degrees Fahrenheit on the Terminal. 
	The potentiometer simulates a thermistor, its varying resistance simulates the varying resistance of a thermistor as it is heated and cooled. 
	See the thermistor equations in the lab 3 folder. User must always be able to return to command line.  */
}
 38e:	df 91       	pop	r29
 390:	cf 91       	pop	r28
 392:	08 95       	ret

00000394 <writeEEPROM>:

void writeEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be written to\r\n");
 394:	8e e0       	ldi	r24, 0x0E	; 14
 396:	91 e0       	ldi	r25, 0x01	; 1
 398:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 39c:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 3a0:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void writeEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be written to\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 3a4:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 3a8:	88 23       	and	r24, r24
 3aa:	d1 f3       	breq	.-12     	; 0x3a0 <writeEEPROM+0xc>
		
		UART_Get();
	}
	EEPROMH = ASCII;
 3ac:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <EEPROMH>
	UART_Puts("\r\nEnter the least significant bit of the address to be written to\r\n");
 3b0:	81 e5       	ldi	r24, 0x51	; 81
 3b2:	91 e0       	ldi	r25, 0x01	; 1
 3b4:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 3b8:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 3bc:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
		UART_Get();
	}
	EEPROMH = ASCII;
	UART_Puts("\r\nEnter the least significant bit of the address to be written to\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 3c0:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 3c4:	88 23       	and	r24, r24
 3c6:	d1 f3       	breq	.-12     	; 0x3bc <writeEEPROM+0x28>
		
		UART_Get();
	}
	EEPROML = ASCII;
 3c8:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <EEPROML>
	UART_Puts("\r\nEnter an 8 bit value to store\r\n");
 3cc:	85 e9       	ldi	r24, 0x95	; 149
 3ce:	91 e0       	ldi	r25, 0x01	; 1
 3d0:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 3d4:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 3d8:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
		UART_Get();
	}
	EEPROML = ASCII;
	UART_Puts("\r\nEnter an 8 bit value to store\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 3dc:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 3e0:	88 23       	and	r24, r24
 3e2:	d1 f3       	breq	.-12     	; 0x3d8 <writeEEPROM+0x44>
		
		UART_Get();
	}
	EEPROMV = ASCII;
 3e4:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <EEPROMV>
	EEPROM_Write();
 3e8:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\nThe data has been stored in EEPROM");
 3ec:	87 eb       	ldi	r24, 0xB7	; 183
 3ee:	91 e0       	ldi	r25, 0x01	; 1
 3f0:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
 3f4:	08 95       	ret

000003f6 <readEEPROM>:
	
}

void readEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be read\r\n");
 3f6:	8c ed       	ldi	r24, 0xDC	; 220
 3f8:	91 e0       	ldi	r25, 0x01	; 1
 3fa:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 3fe:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 402:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void readEEPROM(){
	UART_Puts("\r\nEnter the most significant bit of the address to be read\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 406:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 40a:	88 23       	and	r24, r24
 40c:	d1 f3       	breq	.-12     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
		
		UART_Get();
	}
	EEPROMH = ASCII;
 40e:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <EEPROMH>
	UART_Puts("\r\nEnter the least significant bit of the address to be read\r\n");
 412:	89 e1       	ldi	r24, 0x19	; 25
 414:	92 e0       	ldi	r25, 0x02	; 2
 416:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 41a:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 41e:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
		UART_Get();
	}
	EEPROMH = ASCII;
	UART_Puts("\r\nEnter the least significant bit of the address to be read\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 422:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 426:	88 23       	and	r24, r24
 428:	d1 f3       	breq	.-12     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
		
		UART_Get();
	}
	EEPROML = ASCII;
 42a:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <EEPROML>
	EEPROM_Read();
 42e:	0e 94 12 01 	call	0x224	; 0x224 <EEPROM_Read>
	UART_Put();
 432:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\nThe data has been stored in EEPROM");
 436:	87 eb       	ldi	r24, 0xB7	; 183
 438:	91 e0       	ldi	r25, 0x01	; 1
 43a:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
 43e:	08 95       	ret

00000440 <EEPROM>:
}

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM (W)rite or (R)Read.\r\n");
 440:	87 e5       	ldi	r24, 0x57	; 87
 442:	92 e0       	ldi	r25, 0x02	; 2
 444:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 448:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 44c:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM (W)rite or (R)Read.\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 450:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 454:	88 23       	and	r24, r24
 456:	d1 f3       	breq	.-12     	; 0x44c <EEPROM+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 458:	82 37       	cpi	r24, 0x72	; 114
 45a:	29 f0       	breq	.+10     	; 0x466 <EEPROM+0x26>
 45c:	87 37       	cpi	r24, 0x77	; 119
 45e:	31 f4       	brne	.+12     	; 0x46c <EEPROM+0x2c>
		
		case 'W' | 'w': writeEEPROM();
 460:	0e 94 ca 01 	call	0x394	; 0x394 <writeEEPROM>
		break;
 464:	08 95       	ret
		case 'R' | 'r': readEEPROM();
 466:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <readEEPROM>
		break;
 46a:	08 95       	ret
		default:
		UART_Puts(MS5);
 46c:	8c e4       	ldi	r24, 0x4C	; 76
 46e:	95 e0       	ldi	r25, 0x05	; 5
 470:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 474:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 478:	08 95       	ret

0000047a <setBaud>:
}



void setBaud(int i){         //Helper function that changes the baud rate
	UBRRValue = i;			 //Set UBBRBalue to preferred baud rate
 47a:	80 93 fe 05 	sts	0x05FE, r24	; 0x8005fe <__data_end>
 47e:	90 93 ff 05 	sts	0x05FF, r25	; 0x8005ff <__data_end+0x1>
	UBRR0L = (unsigned char) UBRRValue;		   //The rest of the baud rate goes here.
 482:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UBRR0H = (unsigned char) (UBRRValue >> 8); //Upper four bits of the baud rate go here.
 486:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 48a:	08 95       	ret

0000048c <baudRouter>:
	
	
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
 48c:	86 e7       	ldi	r24, 0x76	; 118
 48e:	92 e0       	ldi	r25, 0x02	; 2
 490:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 494:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 498:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void baudRouter(){
	UART_Puts("\r\nWhat baud rate is preferable?\r\n1: 9600, 2: 14400, 3: 19200, 4: 28800, 5: 38400\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 49c:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 4a0:	88 23       	and	r24, r24
 4a2:	d1 f3       	breq	.-12     	; 0x498 <baudRouter+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 4a4:	83 33       	cpi	r24, 0x33	; 51
 4a6:	e9 f0       	breq	.+58     	; 0x4e2 <baudRouter+0x56>
 4a8:	28 f4       	brcc	.+10     	; 0x4b4 <baudRouter+0x28>
 4aa:	81 33       	cpi	r24, 0x31	; 49
 4ac:	41 f0       	breq	.+16     	; 0x4be <baudRouter+0x32>
 4ae:	82 33       	cpi	r24, 0x32	; 50
 4b0:	79 f0       	breq	.+30     	; 0x4d0 <baudRouter+0x44>
 4b2:	32 c0       	rjmp	.+100    	; 0x518 <baudRouter+0x8c>
 4b4:	84 33       	cpi	r24, 0x34	; 52
 4b6:	f1 f0       	breq	.+60     	; 0x4f4 <baudRouter+0x68>
 4b8:	85 33       	cpi	r24, 0x35	; 53
 4ba:	29 f1       	breq	.+74     	; 0x506 <baudRouter+0x7a>
 4bc:	2d c0       	rjmp	.+90     	; 0x518 <baudRouter+0x8c>
		
		case '1': setBaud(103);
 4be:	87 e6       	ldi	r24, 0x67	; 103
 4c0:	90 e0       	ldi	r25, 0x00	; 0
 4c2:	0e 94 3d 02 	call	0x47a	; 0x47a <setBaud>
		UART_Puts("\r\nBaud rate = 9600.\r\n");
 4c6:	89 ec       	ldi	r24, 0xC9	; 201
 4c8:	92 e0       	ldi	r25, 0x02	; 2
 4ca:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 4ce:	08 95       	ret
		case '2': setBaud(68);
 4d0:	84 e4       	ldi	r24, 0x44	; 68
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	0e 94 3d 02 	call	0x47a	; 0x47a <setBaud>
		UART_Puts("\r\nBaud rate = 14400\r\n");
 4d8:	8f ed       	ldi	r24, 0xDF	; 223
 4da:	92 e0       	ldi	r25, 0x02	; 2
 4dc:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 4e0:	08 95       	ret
		case '3': setBaud(51);
 4e2:	83 e3       	ldi	r24, 0x33	; 51
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	0e 94 3d 02 	call	0x47a	; 0x47a <setBaud>
		UART_Puts("\r\nBaud rate = 19200\r\n");
 4ea:	85 ef       	ldi	r24, 0xF5	; 245
 4ec:	92 e0       	ldi	r25, 0x02	; 2
 4ee:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 4f2:	08 95       	ret
		case '4': setBaud(34);
 4f4:	82 e2       	ldi	r24, 0x22	; 34
 4f6:	90 e0       	ldi	r25, 0x00	; 0
 4f8:	0e 94 3d 02 	call	0x47a	; 0x47a <setBaud>
		UART_Puts("\r\nBaud rate = 28800\r\n");
 4fc:	8b e0       	ldi	r24, 0x0B	; 11
 4fe:	93 e0       	ldi	r25, 0x03	; 3
 500:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 504:	08 95       	ret
		case '5': setBaud(25);
 506:	89 e1       	ldi	r24, 0x19	; 25
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	0e 94 3d 02 	call	0x47a	; 0x47a <setBaud>
		UART_Puts("\r\nBaud rate = 38400\r\n");
 50e:	81 e2       	ldi	r24, 0x21	; 33
 510:	93 e0       	ldi	r25, 0x03	; 3
 512:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 516:	08 95       	ret
		default:
		UART_Puts(MS5);
 518:	8c e4       	ldi	r24, 0x4C	; 76
 51a:	95 e0       	ldi	r25, 0x05	; 5
 51c:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 520:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 524:	08 95       	ret

00000526 <setDataBitNum>:
		break;
	}
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
 526:	87 e3       	ldi	r24, 0x37	; 55
 528:	93 e0       	ldi	r25, 0x03	; 3
 52a:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 52e:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 532:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setDataBitNum(){
	UART_Puts("\r\nHow many data bits are preferable?\r\n5, 6, 7, 8 , or 9 bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 536:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 53a:	88 23       	and	r24, r24
 53c:	d1 f3       	breq	.-12     	; 0x532 <setDataBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 53e:	87 33       	cpi	r24, 0x37	; 55
 540:	a9 f0       	breq	.+42     	; 0x56c <setDataBitNum+0x46>
 542:	28 f4       	brcc	.+10     	; 0x54e <setDataBitNum+0x28>
 544:	85 33       	cpi	r24, 0x35	; 53
 546:	41 f0       	breq	.+16     	; 0x558 <setDataBitNum+0x32>
 548:	86 33       	cpi	r24, 0x36	; 54
 54a:	59 f0       	breq	.+22     	; 0x562 <setDataBitNum+0x3c>
 54c:	2d c0       	rjmp	.+90     	; 0x5a8 <setDataBitNum+0x82>
 54e:	88 33       	cpi	r24, 0x38	; 56
 550:	91 f0       	breq	.+36     	; 0x576 <setDataBitNum+0x50>
 552:	89 33       	cpi	r24, 0x39	; 57
 554:	d1 f0       	breq	.+52     	; 0x58a <setDataBitNum+0x64>
 556:	28 c0       	rjmp	.+80     	; 0x5a8 <setDataBitNum+0x82>
		
		case '5':
		UCSR0C |= (0<<2)&&(0<<1); //if the bits 2-0 of UCSR0C == 000
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 5\r\n");
 558:	86 e7       	ldi	r24, 0x76	; 118
 55a:	93 e0       	ldi	r25, 0x03	; 3
 55c:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 560:	08 95       	ret
		case '6':
		UCSR0C |= (0<<2)&&(1<<1); //if bits 2-0 of UCSR0C == 001
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 6\r\n");
 562:	8d e8       	ldi	r24, 0x8D	; 141
 564:	93 e0       	ldi	r25, 0x03	; 3
 566:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 56a:	08 95       	ret
		case '7':
		UCSR0C |= (1<<2)&&(0<<1); //if bits 2-0 of UCSr0C == 010
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 7\r\n");
 56c:	84 ea       	ldi	r24, 0xA4	; 164
 56e:	93 e0       	ldi	r25, 0x03	; 3
 570:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 574:	08 95       	ret
		case '8':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 011
 576:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 57a:	81 60       	ori	r24, 0x01	; 1
 57c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (0<<2);
		UART_Puts("\r\n# of Data Bits = 8\r\n");
 580:	8b eb       	ldi	r24, 0xBB	; 187
 582:	93 e0       	ldi	r25, 0x03	; 3
 584:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 588:	08 95       	ret
		case '9':
		UCSR0C |= (1<<2)&&(1<<1); //if bits 2-0 of USCR0C == 111
 58a:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 58e:	81 60       	ori	r24, 0x01	; 1
 590:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UCSR0B |= (1<<2);
 594:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 598:	84 60       	ori	r24, 0x04	; 4
 59a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		UART_Puts("\r\n# of Data Bits = 9\r\n");
 59e:	82 ed       	ldi	r24, 0xD2	; 210
 5a0:	93 e0       	ldi	r25, 0x03	; 3
 5a2:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 5a6:	08 95       	ret
		default:
		UART_Puts(MS5);
 5a8:	8c e4       	ldi	r24, 0x4C	; 76
 5aa:	95 e0       	ldi	r25, 0x05	; 5
 5ac:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 5b0:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 5b4:	08 95       	ret

000005b6 <setParity>:
		break;
	}
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
 5b6:	89 ee       	ldi	r24, 0xE9	; 233
 5b8:	93 e0       	ldi	r25, 0x03	; 3
 5ba:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 5be:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 5c2:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setParity(){
	UART_Puts("\r\nWhat sort of parity is preferable?\r\n(N)o Parity, (O)dd parity, (E)ven Parity\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 5c6:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 5ca:	88 23       	and	r24, r24
 5cc:	d1 f3       	breq	.-12     	; 0x5c2 <setParity+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 5ce:	8e 36       	cpi	r24, 0x6E	; 110
 5d0:	29 f0       	breq	.+10     	; 0x5dc <setParity+0x26>
 5d2:	8f 36       	cpi	r24, 0x6F	; 111
 5d4:	41 f0       	breq	.+16     	; 0x5e6 <setParity+0x30>
 5d6:	85 36       	cpi	r24, 0x65	; 101
 5d8:	a9 f4       	brne	.+42     	; 0x604 <setParity+0x4e>
 5da:	0f c0       	rjmp	.+30     	; 0x5fa <setParity+0x44>
		
		case 'N' | 'n':
		UCSR0C |= (0<<5)&&(0<<4);
		UART_Puts("\r\nParity = No Parity\r\n");
 5dc:	8a e3       	ldi	r24, 0x3A	; 58
 5de:	94 e0       	ldi	r25, 0x04	; 4
 5e0:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 5e4:	08 95       	ret
		case 'O' | 'o':
		UCSR0C |= (1<<5)&&(1<<4);
 5e6:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 5ea:	81 60       	ori	r24, 0x01	; 1
 5ec:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\nParity = Odd Parity\r\n");
 5f0:	81 e5       	ldi	r24, 0x51	; 81
 5f2:	94 e0       	ldi	r25, 0x04	; 4
 5f4:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 5f8:	08 95       	ret
		case 'E' | 'e':
		UCSR0C |= (1<<5)&&(0<<4);
		UART_Puts("\r\nParity = Even Parity\r\n");
 5fa:	89 e6       	ldi	r24, 0x69	; 105
 5fc:	94 e0       	ldi	r25, 0x04	; 4
 5fe:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 602:	08 95       	ret
		default:
		UART_Puts(MS5);
 604:	8c e4       	ldi	r24, 0x4C	; 76
 606:	95 e0       	ldi	r25, 0x05	; 5
 608:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 60c:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 610:	08 95       	ret

00000612 <setStopBitNum>:
		break;
	}
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
 612:	82 e8       	ldi	r24, 0x82	; 130
 614:	94 e0       	ldi	r25, 0x04	; 4
 616:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 61a:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 61e:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
}

void setStopBitNum(){
	UART_Puts("\r\nHow many stops bits is preferable?\r\n(1) bit or (2) bits\r\n");
	ASCII = '\0';
	while(ASCII == '\0'){
 622:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 626:	88 23       	and	r24, r24
 628:	d1 f3       	breq	.-12     	; 0x61e <setStopBitNum+0xc>
		
		UART_Get();
	}
	switch(ASCII){
 62a:	81 33       	cpi	r24, 0x31	; 49
 62c:	19 f0       	breq	.+6      	; 0x634 <setStopBitNum+0x22>
 62e:	82 33       	cpi	r24, 0x32	; 50
 630:	31 f0       	breq	.+12     	; 0x63e <setStopBitNum+0x2c>
 632:	0f c0       	rjmp	.+30     	; 0x652 <setStopBitNum+0x40>
		
		case '1':
		UCSR0C |= (0<<3);
		UART_Puts("\r\n# of Stop Bits = 1\r\n");
 634:	8e eb       	ldi	r24, 0xBE	; 190
 636:	94 e0       	ldi	r25, 0x04	; 4
 638:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 63c:	08 95       	ret
		case '2':
		UCSR0C |= (1<<3);
 63e:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 642:	88 60       	ori	r24, 0x08	; 8
 644:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		UART_Puts("\r\n# of Stop Bits = 2\r\n");
 648:	85 ed       	ldi	r24, 0xD5	; 213
 64a:	94 e0       	ldi	r25, 0x04	; 4
 64c:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		break;
 650:	08 95       	ret
		default:
		UART_Puts(MS5);
 652:	8c e4       	ldi	r24, 0x4C	; 76
 654:	95 e0       	ldi	r25, 0x05	; 5
 656:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 65a:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 65e:	08 95       	ret

00000660 <Params>:
	}
}

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
 660:	8c ee       	ldi	r24, 0xEC	; 236
 662:	94 e0       	ldi	r25, 0x04	; 4
 664:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';
 668:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while(ASCII == '\0'){
		
		UART_Get();
 66c:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Params(void)					//Router for  USART parameter changes
{
	UART_Puts(MS7);
	ASCII = '\0';
	while(ASCII == '\0'){
 670:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 674:	88 23       	and	r24, r24
 676:	d1 f3       	breq	.-12     	; 0x66c <Params+0xc>
		
		UART_Get();
	}
	switch(ASCII){                  //For each parameter change send to another router which handles setting the parameter.
 678:	84 36       	cpi	r24, 0x64	; 100
 67a:	61 f0       	breq	.+24     	; 0x694 <Params+0x34>
 67c:	18 f4       	brcc	.+6      	; 0x684 <Params+0x24>
 67e:	82 36       	cpi	r24, 0x62	; 98
 680:	31 f0       	breq	.+12     	; 0x68e <Params+0x2e>
 682:	11 c0       	rjmp	.+34     	; 0x6a6 <Params+0x46>
 684:	80 37       	cpi	r24, 0x70	; 112
 686:	49 f0       	breq	.+18     	; 0x69a <Params+0x3a>
 688:	83 37       	cpi	r24, 0x73	; 115
 68a:	51 f0       	breq	.+20     	; 0x6a0 <Params+0x40>
 68c:	0c c0       	rjmp	.+24     	; 0x6a6 <Params+0x46>
		
		case 'B' | 'b': baudRouter();
 68e:	0e 94 46 02 	call	0x48c	; 0x48c <baudRouter>
		break;
 692:	08 95       	ret
		case 'D' | 'd': setDataBitNum();
 694:	0e 94 93 02 	call	0x526	; 0x526 <setDataBitNum>
		break;
 698:	08 95       	ret
		case 'P' | 'p': setParity();
 69a:	0e 94 db 02 	call	0x5b6	; 0x5b6 <setParity>
		break;
 69e:	08 95       	ret
		case 'S' | 's': setStopBitNum();
 6a0:	0e 94 09 03 	call	0x612	; 0x612 <setStopBitNum>
		break;
 6a4:	08 95       	ret
		default:
		UART_Puts(MS5);
 6a6:	8c e4       	ldi	r24, 0x4C	; 76
 6a8:	95 e0       	ldi	r25, 0x05	; 5
 6aa:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 6ae:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 6b2:	08 95       	ret

000006b4 <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 6b4:	85 e7       	ldi	r24, 0x75	; 117
 6b6:	95 e0       	ldi	r25, 0x05	; 5
 6b8:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
	ASCII = '\0';						
 6bc:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 6c0:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 6c4:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <ASCII>
 6c8:	88 23       	and	r24, r24
 6ca:	d1 f3       	breq	.-12     	; 0x6c0 <Command+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 6cc:	85 36       	cpi	r24, 0x65	; 101
 6ce:	79 f0       	breq	.+30     	; 0x6ee <Command+0x3a>
 6d0:	18 f4       	brcc	.+6      	; 0x6d8 <Command+0x24>
 6d2:	81 36       	cpi	r24, 0x61	; 97
 6d4:	49 f0       	breq	.+18     	; 0x6e8 <Command+0x34>
 6d6:	11 c0       	rjmp	.+34     	; 0x6fa <Command+0x46>
 6d8:	8c 36       	cpi	r24, 0x6C	; 108
 6da:	19 f0       	breq	.+6      	; 0x6e2 <Command+0x2e>
 6dc:	85 37       	cpi	r24, 0x75	; 117
 6de:	51 f0       	breq	.+20     	; 0x6f4 <Command+0x40>
 6e0:	0c c0       	rjmp	.+24     	; 0x6fa <Command+0x46>
	{
		case 'L' | 'l': LCD();
 6e2:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCD>
		break;
 6e6:	08 95       	ret
		case 'A' | 'a': ADC();
 6e8:	0e 94 72 01 	call	0x2e4	; 0x2e4 <ADC>
		break;
 6ec:	08 95       	ret
		case 'E' | 'e': EEPROM();
 6ee:	0e 94 20 02 	call	0x440	; 0x440 <EEPROM>
		break;
 6f2:	08 95       	ret
		case 'U' | 'u': Params();   //Send USART parameter changes to another router   
 6f4:	0e 94 30 03 	call	0x660	; 0x660 <Params>
		break;
 6f8:	08 95       	ret
		default:
		UART_Puts(MS5);
 6fa:	8c e4       	ldi	r24, 0x4C	; 76
 6fc:	95 e0       	ldi	r25, 0x05	; 5
 6fe:	0e 94 20 01 	call	0x240	; 0x240 <UART_Puts>
		HELP();
 702:	0e 94 4f 01 	call	0x29e	; 0x29e <HELP>
 706:	08 95       	ret

00000708 <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 708:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 70c:	0e 94 42 01 	call	0x284	; 0x284 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 710:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <Command>
 714:	fd cf       	rjmp	.-6      	; 0x710 <main+0x8>

00000716 <__divmodhi4>:
 716:	97 fb       	bst	r25, 7
 718:	07 2e       	mov	r0, r23
 71a:	16 f4       	brtc	.+4      	; 0x720 <__divmodhi4+0xa>
 71c:	00 94       	com	r0
 71e:	07 d0       	rcall	.+14     	; 0x72e <__divmodhi4_neg1>
 720:	77 fd       	sbrc	r23, 7
 722:	09 d0       	rcall	.+18     	; 0x736 <__divmodhi4_neg2>
 724:	0e 94 9f 03 	call	0x73e	; 0x73e <__udivmodhi4>
 728:	07 fc       	sbrc	r0, 7
 72a:	05 d0       	rcall	.+10     	; 0x736 <__divmodhi4_neg2>
 72c:	3e f4       	brtc	.+14     	; 0x73c <__divmodhi4_exit>

0000072e <__divmodhi4_neg1>:
 72e:	90 95       	com	r25
 730:	81 95       	neg	r24
 732:	9f 4f       	sbci	r25, 0xFF	; 255
 734:	08 95       	ret

00000736 <__divmodhi4_neg2>:
 736:	70 95       	com	r23
 738:	61 95       	neg	r22
 73a:	7f 4f       	sbci	r23, 0xFF	; 255

0000073c <__divmodhi4_exit>:
 73c:	08 95       	ret

0000073e <__udivmodhi4>:
 73e:	aa 1b       	sub	r26, r26
 740:	bb 1b       	sub	r27, r27
 742:	51 e1       	ldi	r21, 0x11	; 17
 744:	07 c0       	rjmp	.+14     	; 0x754 <__udivmodhi4_ep>

00000746 <__udivmodhi4_loop>:
 746:	aa 1f       	adc	r26, r26
 748:	bb 1f       	adc	r27, r27
 74a:	a6 17       	cp	r26, r22
 74c:	b7 07       	cpc	r27, r23
 74e:	10 f0       	brcs	.+4      	; 0x754 <__udivmodhi4_ep>
 750:	a6 1b       	sub	r26, r22
 752:	b7 0b       	sbc	r27, r23

00000754 <__udivmodhi4_ep>:
 754:	88 1f       	adc	r24, r24
 756:	99 1f       	adc	r25, r25
 758:	5a 95       	dec	r21
 75a:	a9 f7       	brne	.-22     	; 0x746 <__udivmodhi4_loop>
 75c:	80 95       	com	r24
 75e:	90 95       	com	r25
 760:	bc 01       	movw	r22, r24
 762:	cd 01       	movw	r24, r26
 764:	08 95       	ret

00000766 <_exit>:
 766:	f8 94       	cli

00000768 <__stop_program>:
 768:	ff cf       	rjmp	.-2      	; 0x768 <__stop_program>
